{"version":3,"sources":["../../src/lib/A-Signal/entities/A-Signal.entity.ts","../../src/lib/A-Signal/entities/A-SignalVector.entity.ts","../../src/lib/A-Signal/context/A-SignalState.context.ts","../../src/lib/A-Signal/context/A-SignalConfig.context.ts","../../src/lib/A-Signal/components/A-SignalBus.constants.ts","../../src/lib/A-Signal/components/A-SignalBus.error.ts","../../src/lib/A-Signal/components/A-SignalBus.component.ts"],"names":["A_Entity","A_Frame","A_Fragment","A_Context","A_SignalBusFeatures","A_Scope","A_Error"],"mappings":"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","file":"a-signal.mjs","sourcesContent":["import { A_Entity, A_Scope } from \"@adaas/a-concept\";\nimport { A_Signal_Init, A_Signal_Serialized } from \"../A-Signal.types\";\nimport { A_Frame } from \"@adaas/a-frame\";\n\n/**\n * A Signal Entity is an individual signal instance that carries data.\n * Signals is a event types that uses for vectors of signals to be used for further processing. \n * \n * Comparing to standard events, signals should be used in case when the event impacts some \"state\" \n * and the state should be used instead of the event itself.\n * \n * For example, a signal can represent the current status of a user (online/offline/away), \n * while an event would represent a single action (user logged in/logged out).\n * \n * Signals are typically used in scenarios where the current state is more important than individual events, \n * such as monitoring systems, real-time dashboards, or stateful applications.\n */\n@A_Frame.Entity({\n    namespace: 'A-Utils',\n    name: 'A-Signal',\n    description: 'A Signal Entity represents an individual signal instance that carries data, used for managing state within an application context. Signals are designed to reflect the current state rather than individual events, making them suitable for scenarios where state monitoring and real-time updates are essential.'\n})\nexport class A_Signal<\n    _TSignalDataType extends Record<string, any> = Record<string, any>\n> extends A_Entity<A_Signal_Init<_TSignalDataType>, A_Signal_Serialized<_TSignalDataType>> {\n\n\n    // ========================================================================\n    // ========================== Static Methods ==============================\n    // ========================================================================\n    /**\n     * Allows to define default data for the signal.\n     * \n     * If no data is provided during initialization, the default data will be used.\n     * \n     * @returns \n     */\n    static async default(): Promise<A_Signal | undefined> {\n        return undefined;\n    }\n\n    // ========================================================================\n    // ========================== Instance Properties ========================\n    // ========================================================================\n\n    /**\n     * The actual data carried by the signal.\n     */\n    data!: _TSignalDataType;\n\n    /**\n      * Generates signal hash uses for comparison\n      * \n      * @param str \n      */\n    protected createHash(str?: string): string\n    protected createHash(str?: undefined): string\n    protected createHash(str?: Record<string, any>): string\n    protected createHash(str?: Array<any>): string\n    protected createHash(str?: number): string\n    protected createHash(str?: boolean): string\n    protected createHash(str?: null): string\n    protected createHash(map?: Map<any, any>): string\n    protected createHash(set?: Set<any>): string\n    protected createHash(str?: any): string {\n        let hashSource: string;\n\n        if (str instanceof Map) {\n            hashSource = JSON.stringify(Array.from(str.entries()));\n        } else if (str instanceof Set) {\n            hashSource = JSON.stringify(Array.from(str.values()));\n        } else {\n            switch (typeof str) {\n                case 'string':\n                    hashSource = str;\n                    break;\n                case 'undefined':\n                    hashSource = 'undefined';\n                    break;\n\n                case 'object':\n                    if ('toJSON' in str)\n                        hashSource = JSON.stringify(str.toJSON());\n\n                    else\n                        hashSource = JSON.stringify(str);\n                    break;\n                case 'number':\n                    hashSource = str.toString();\n                    break;\n                case 'boolean':\n                    hashSource = str ? 'true' : 'false';\n                    break;\n                case 'function':\n                    hashSource = str.toString();\n                    break;\n                default:\n                    hashSource = String(str);\n            }\n        }\n\n        let hash = 0, i, chr;\n        for (i = 0; i < hashSource.length; i++) {\n            chr = hashSource.charCodeAt(i);\n            hash = ((hash << 5) - hash) + chr;\n            hash |= 0; // Convert to 32bit integer\n        }\n\n        const hashString = hash.toString();\n\n        return hashString;\n    }\n\n    /**\n     * This method compares the current signal with another signal instance by deduplication ID\n     * this id can be configured during initialization with the \"id\" property.\n     * \n     * example: \n     * * const signalA = new A_Signal({ id: ['user-status', 'user123'], data: { status: 'online' } });\n     * * const signalB = new A_Signal({ id: ['user-status', 'user123'], data: { status: 'offline' } });\n     * \n     * signalA.compare(signalB) // true because both signals have the same deduplication ID\n     * \n     * @param other \n     * @returns \n     */\n    compare(other: A_Signal<_TSignalDataType>): boolean {\n        if (this.aseid.id !== other.aseid.id) {\n            return false;\n        }\n\n        return true;\n    }\n    \n\n\n    fromJSON(serializedEntity: A_Signal_Serialized<_TSignalDataType>): void {\n        super.fromJSON(serializedEntity);\n        this.data = serializedEntity.data;\n    }\n\n\n    fromNew(newEntity: A_Signal_Init<_TSignalDataType>): void {\n        this.data = newEntity.data;\n\n        const identity = newEntity.id || {\n            name: newEntity.name,\n            data: this.data\n        };\n\n        const id = this.createHash(identity);\n\n        this.aseid = this.generateASEID({\n            entity: newEntity.name,\n            id: id,\n        });\n    }\n\n\n    toJSON(): A_Signal_Serialized<_TSignalDataType> {\n        return {\n            ...super.toJSON(),\n            data: this.data\n        };\n    }\n\n}","import { A_Entity, A_Scope, A_TYPES__Component_Constructor, A_TYPES__Entity_Constructor } from \"@adaas/a-concept\";\nimport { A_SignalVector_Serialized, A_SignalVector_Init, A_Signal_TSignalsConstructors, A_SignalTValue, A_SignalTValueArray } from \"../A-Signal.types\";\nimport { A_Signal } from \"./A-Signal.entity\";\nimport { A_Frame } from \"@adaas/a-frame\";\n\n\n/**\n * A Signal Vector Entity is a collection of signals structured in a specific way.\n * It allows grouping multiple signals together for batch processing or transmission.\n * \n * Signal Vectors are useful in scenarios where multiple related signals need to be handled together,\n * as a state of the system or a snapshot of various parameters at a given time.\n * \n * @template TSignalsConstructors - Array of signal constructor types (e.g., [typeof MySignal, typeof CustomSignal])\n * @template TSignals - Array of signal instances derived from constructors\n */\n@A_Frame.Entity({\n    namespace: 'A-Utils',\n    name: 'A-SignalVector',\n    description: 'A Signal Vector Entity represents a collection of signals structured in a specific way, allowing for batch processing and transmission of related signals as a unified state representation.'\n})\nexport class A_SignalVector<\n    TSignals extends A_Signal[] = A_Signal[],\n> extends A_Entity<A_SignalVector_Init<TSignals>> {\n\n    /**\n     * The structure of the signal vector, defining the types of signals it contains.\n     * \n     * For example:\n     * [UserSignInSignal, UserStatusSignal, UserActivitySignal]\n     * \n     * [!] if not provided, it will be derived from the signals values.\n     */\n    protected _structure?: A_Signal_TSignalsConstructors<TSignals>;\n    /**\n     * It's actual vector Values of Signals like :\n     * [UserActionSignal, UserMousePositionSignal, ExternalDependencySignal]\n     */\n    protected _signals!: TSignals\n\n    constructor(values: TSignals, structure?: { [K in keyof TSignals]: TSignals[K] extends A_Signal ? A_TYPES__Entity_Constructor<TSignals[K]> : never })\n    constructor(serialized: A_SignalVector_Serialized)\n    constructor(param1: TSignals | A_SignalVector_Serialized, param2?: A_Signal_TSignalsConstructors<TSignals>) {\n\n        if ('aseid' in param1) {\n            // Handle serialized case\n            super(param1 as A_SignalVector_Serialized);\n        } else {\n            // Handle init case  \n            super({\n                structure: param2 ? param2 : (param1 as TSignals).map(s => s.constructor as A_TYPES__Entity_Constructor<TSignals[number]>) as A_Signal_TSignalsConstructors<TSignals>,\n                values: param1 as TSignals\n            } as A_SignalVector_Init<TSignals>);\n        }\n    }\n\n\n    fromNew(newEntity: A_SignalVector_Init<TSignals>): void {\n        super.fromNew(newEntity);\n        this._structure = newEntity.structure;\n        this._signals = newEntity.values;\n    }\n\n    /**\n     * The structure of the signal vector, defining the types of signals it contains.\n     * \n     * For example:\n     * [UserSignInSignal, UserStatusSignal, UserActivitySignal]\n     * \n     */\n    get structure(): A_Signal_TSignalsConstructors<TSignals> {\n        return this._structure || this._signals.map(s => s.constructor as A_TYPES__Entity_Constructor<TSignals[number]>) as A_Signal_TSignalsConstructors<TSignals>;\n    }\n\n\n    get length(): number {\n        return this.structure.length;\n    }\n\n\n    /**\n     * Enables iteration over the signals in the vector.\n     * \n     * @returns \n     */\n    [Symbol.iterator](): Iterator<TSignals[number]> {\n        let pointer = 0;\n        const signals = this.structure.map((signalConstructor) => {\n            const signalIndex = this._signals.findIndex(s => s.constructor === signalConstructor);\n            return signalIndex !== -1 ? this._signals[signalIndex] : undefined;\n        }) as TSignals[number][];\n\n        return {\n            next(): IteratorResult<TSignals[number]> {\n                if (pointer < signals.length) {\n                    return {\n                        done: false,\n                        value: signals[pointer++]\n                    };\n                } else {\n                    return {\n                        done: true,\n                        value: undefined as any\n                    };\n                }\n            }\n        };\n    }\n\n\n    /**\n     * Allows to match the current Signal Vector with another Signal Vector by comparing each signal in the structure.\n     * This method returns true if all signals in the vector match the corresponding signals in the other vector.\n     * \n     * @param other \n     * @returns \n     */\n    match(other: A_SignalVector<TSignals>): boolean {\n        if (this.length !== other.length) {\n            return false;\n        }\n\n        for (let i = 0; i < this.length; i++) {\n            const thisSignalConstructor = this.structure[i];\n            const otherSignalConstructor = other.structure[i];\n\n            if (thisSignalConstructor !== otherSignalConstructor) {\n                return false;\n            }\n\n            const thisSignalIndex = this._signals.findIndex(s => s.constructor === thisSignalConstructor);\n            const otherSignalIndex = other._signals.findIndex(s => s.constructor === otherSignalConstructor);\n\n            const thisSignal = thisSignalIndex !== -1 ? this._signals[thisSignalIndex] : undefined;\n            const otherSignal = otherSignalIndex !== -1 ? other._signals[otherSignalIndex] : undefined;\n\n            if (thisSignal && otherSignal) {\n                if (!thisSignal.compare(otherSignal)) {\n                    return false;\n                }\n            } else if (thisSignal || otherSignal) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \n    /**\n     * This method should ensure that the current Signal Vector contains all signals from the provided Signal Vector.\n     * \n     * @param signal \n     */\n    contains(signal: A_SignalVector): boolean{\n        for (const signalConstructor of signal.structure) {\n            const signalIndex = this._signals.findIndex(s => s.constructor === signalConstructor);\n            if (signalIndex === -1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks if the vector contains a signal of the specified type.\n     * \n     * @param signal \n     */\n    has(signal: A_Signal): boolean\n    has(signalConstructor: A_TYPES__Entity_Constructor<A_Signal>): boolean\n    has(param1: A_Signal | A_TYPES__Entity_Constructor<A_Signal>): boolean {\n        let signalConstructor: A_TYPES__Entity_Constructor<A_Signal>;\n        if (param1 instanceof A_Entity) {\n            signalConstructor = param1.constructor as A_TYPES__Entity_Constructor<A_Signal>;\n        } else {\n            signalConstructor = param1;\n        }\n        return this.structure.includes(signalConstructor as any);\n    }\n\n    /**\n     * Retrieves the signal of the specified type from the vector.\n     * \n     * @param signal \n     */\n    get<T extends A_Signal>(signal: T): T | undefined\n    get<T extends A_Signal>(signalConstructor: A_TYPES__Entity_Constructor<T>): T | undefined\n    get<T extends A_Signal>(param1: T | A_TYPES__Entity_Constructor<T>): T | undefined {\n        let signalConstructor: A_TYPES__Entity_Constructor<A_Signal>;\n\n        if (param1 instanceof A_Entity) {\n            signalConstructor = param1.constructor as A_TYPES__Entity_Constructor<A_Signal>;\n        } else {\n            signalConstructor = param1 as A_TYPES__Entity_Constructor<A_Signal>;\n        }\n\n        const index = this._signals.findIndex(s => s.constructor === signalConstructor);\n        if (index === -1) {\n            return undefined;\n        }\n        return this._signals[index] as T;\n    }\n\n\n    /**\n     * Converts to Array of values of signals in the vector\n     * Maintains the order specified in the structure/generic type\n     * \n     * @param structure - Optional structure to override the default ordering\n     * @returns Array of signal instances in the specified order\n     */\n    async toVector<\n        T extends Array<A_Signal> = TSignals,\n    >(\n        structure?: A_Signal_TSignalsConstructors<T>\n    ): Promise<T> {\n        const usedStructure = structure || this.structure;\n\n        return usedStructure.map((signalConstructor) => {\n            const signalIndex = this._signals.findIndex(s => s.constructor === signalConstructor);\n            return signalIndex !== -1 ? this._signals[signalIndex] : undefined;\n        }) as T;\n    }\n\n\n    /**\n     * Converts to Array of data of signals in the vector\n     * Maintains the order specified in the structure/generic type\n     * \n     * @param structure - Optional structure to override the default ordering\n     * @returns Array of serialized signal data in the specified order\n     */\n    async toDataVector<\n        T extends A_Signal[] = TSignals,\n    >(\n        structure?: A_Signal_TSignalsConstructors<T>\n    ): Promise<A_SignalTValueArray<T>> {\n\n        const usedStructure = structure || this.structure;\n\n        const results: Array<any> = [];\n\n        for (const signalConstructor of usedStructure) {\n            const signalIndex = this._signals.findIndex(s => s.constructor === signalConstructor);\n            let data: any;\n            if (signalIndex === -1) {\n\n                data = await (signalConstructor as typeof A_Signal).default()\n\n            } else {\n                const signal = this._signals[signalIndex];\n                data = signal;\n            }\n\n\n            results.push(data?.toJSON().data);\n        }\n\n        return results as A_SignalTValueArray<T>;\n    }\n\n    /**\n     * Converts to Object with signal constructor names as keys and their corresponding data values\n     * Uses the structure ordering to ensure consistent key ordering\n     * \n     * @returns Object with signal constructor names as keys and signal data as values\n     */\n    async toObject<\n        T extends Array<A_Signal> = TSignals,\n    >(\n        structure?: { [K in keyof T]: T[K] extends A_Signal ? A_TYPES__Entity_Constructor<T[K]> : never }\n    ): Promise<{ [key: string]: T[number] extends A_Signal<infer D> ? D | undefined : never }> {\n\n        const usedStructure = structure || this.structure;\n\n        const obj: { [key: string]: T[number] extends A_Signal<infer D> ? D | undefined : never } = {};\n        usedStructure.forEach((signalConstructor) => {\n            const signalName = signalConstructor.name;\n            const signalIndex = this._signals.findIndex(s => s.constructor === signalConstructor);\n\n            if (signalIndex !== -1) {\n                const signal = this._signals[signalIndex];\n                obj[signalName] = signal.toJSON().data as any;\n            } else {\n                obj[signalName] = undefined as any;\n            }\n        });\n\n        return obj;\n    }\n\n\n    /**\n     * Serializes the Signal Vector to a JSON-compatible format.\n     * \n     * \n     * @returns \n     */\n    toJSON(): A_SignalVector_Serialized {\n        return {\n            ...super.toJSON(),\n            structure: this.structure.map(s => s.name),\n            values: this._signals.map(s => s.toJSON())\n        };\n    }\n}\n","import { A_Context, A_Fragment, A_TYPES__Component_Constructor } from \"@adaas/a-concept\";\nimport { A_Signal } from \"../entities/A-Signal.entity\";\nimport { A_SignalVector } from \"../entities/A-SignalVector.entity\";\nimport { A_Frame } from \"@adaas/a-frame\";\n\n/**\n * A_SignalState manages the latest state of all signals within a given scope.\n * \n * This class maintains a mapping between signal constructors and their most recently emitted values,\n * providing a centralized state store for signal management within an application context.\n * \n * @template TSignalData - Union type of all possible signal data types that can be stored (must extend Record<string, any>)\n * \n * The generic ensures type safety by maintaining correspondence between:\n * - Signal constructor types and their data types\n * - Signal instances and their emitted value types\n * - Vector structure and the data it contains\n */\n@A_Frame.Fragment({\n    namespace: 'A-Utils',\n    name: 'A-SignalState',\n    description: 'Manages the latest state of all signals within a given scope, maintaining a mapping between signal constructors and their most recently emitted values.'\n})\nexport class A_SignalState<\n    TSignalData extends Record<string, any> = Record<string, any>\n> extends A_Fragment {\n\n    /**\n     * Internal map storing the relationship between signal constructors and their latest values\n     * Key: Signal constructor function\n     * Value: Latest emitted data from that signal type\n     */\n    protected _state: Map<A_TYPES__Component_Constructor<A_Signal>, A_Signal> = new Map();\n\n    /**\n     * Previous state map to track changes between signal emissions\n     * Key: Signal constructor function\n     * Value: Previous emitted data from that signal type\n     */\n    protected _prevState: Map<A_TYPES__Component_Constructor<A_Signal>, A_Signal> = new Map();\n\n    /**\n     * Optional structure defining the ordered list of signal constructors\n     * Used for vector operations and initialization\n     */\n    protected _structure: Array<A_TYPES__Component_Constructor<A_Signal>>;\n\n\n    /**\n     * Gets the ordered structure of signal constructors\n     * @returns Array of signal constructors in their defined order\n     */\n    get structure(): Array<A_TYPES__Component_Constructor<A_Signal>> {\n        return this._structure || [];\n    }\n\n    /**\n     * Creates a new A_SignalState instance\n     * \n     * @param structure - Optional array defining the ordered structure of signal constructors\n     *                   This structure is used for vector operations and determines the order\n     *                   in which signals are processed and serialized\n     */\n    constructor(\n        structure: A_TYPES__Component_Constructor<A_Signal>[]\n    ) {\n        super({ name: \"A_SignalState\" });\n\n        this._structure = structure;\n\n        // Initialize the state map with undefined values for each signal in the structure\n        // This ensures all expected signals have entries in the state map from the start\n      \n    }\n\n\n    /**\n     * Sets the latest value for a specific signal type\n     * \n     * @param signal - The signal constructor to associate the value with\n     * @param value - The data value emitted by the signal\n     */\n    set(\n        signal: A_Signal,\n        value: A_Signal\n    ): void\n    set(\n        signal: A_Signal\n    ): void\n    set(\n        signal: A_TYPES__Component_Constructor<A_Signal>,\n        value: A_Signal\n    ): void\n    set(\n        param1: A_TYPES__Component_Constructor<A_Signal> | A_Signal,\n        param2?: A_Signal\n    ): void {\n        const signal = param1 instanceof A_Signal ? param1.constructor as A_TYPES__Component_Constructor<A_Signal> : param1;\n        const value = param1 instanceof A_Signal ? param1 : param2!;\n\n        this._prevState.set(signal, this._state.get(signal)!);\n        this._state.set(signal, value);\n    }\n\n    /**\n     * Retrieves the latest value for a specific signal type\n     * \n     * @param signal - The signal constructor to get the value for\n     * @returns The latest data value or undefined if no value has been set\n     */\n    get(\n        signal: A_Signal\n    ): A_Signal | undefined\n    get(\n        signal: A_TYPES__Component_Constructor<A_Signal>\n    ): A_Signal | undefined\n    get(\n        param: A_TYPES__Component_Constructor<A_Signal> | A_Signal\n    ): A_Signal | undefined {\n        const signal = param instanceof A_Signal ? param.constructor as A_TYPES__Component_Constructor<A_Signal> : param;\n        return this._state.get(signal);\n    }\n\n    /**\n     * Retrieves the previous value for a specific signal type\n     * \n     * @param signal \n     */\n    getPrev(\n        signal: A_Signal\n    ): A_Signal | undefined\n    getPrev(\n        signal: A_TYPES__Component_Constructor<A_Signal>\n    ): A_Signal | undefined\n    getPrev(\n        param: A_TYPES__Component_Constructor<A_Signal> | A_Signal\n    ): A_Signal | undefined {\n        const signal = param instanceof A_Signal ? param.constructor as A_TYPES__Component_Constructor<A_Signal> : param;\n        return this._prevState.get(signal);\n    }   \n\n    /**\n     * Checks if a signal type has been registered in the state\n     * \n     * @param signal - The signal constructor to check for\n     * @returns True if the signal type exists in the state map\n     */\n    has(\n        signal: A_Signal\n    ): boolean\n    has(\n        signal: A_TYPES__Component_Constructor<A_Signal>\n    ): boolean\n    has(\n        param: A_TYPES__Component_Constructor<A_Signal> | A_Signal\n    ): boolean {\n        const signal = param instanceof A_Signal ? param.constructor as A_TYPES__Component_Constructor<A_Signal> : param;\n\n        return this.structure.includes(signal);\n    }\n\n    /**\n     * Removes a signal type and its associated value from the state\n     * \n     * @param signal - The signal constructor to remove\n     * @returns True if the signal was successfully deleted, false if it didn't exist\n     */\n    delete(\n        signal: A_Signal\n    ): boolean\n    delete(\n        signal: A_TYPES__Component_Constructor<A_Signal>\n    ): boolean\n    delete(\n        param: A_TYPES__Component_Constructor<A_Signal> | A_Signal\n    ): boolean {\n        const signal = param instanceof A_Signal ? param.constructor as A_TYPES__Component_Constructor<A_Signal> : param;\n        return this._state.delete(signal);\n    }\n\n\n    /**\n     * Converts the current state to a vector (ordered array) format\n     * \n     * The order is determined by the structure array provided during construction.\n     * Each position in the vector corresponds to a specific signal type's latest value.\n     * \n     * @returns Array of signal values in the order defined by the structure\n     * @throws Error if structure is not defined or if any signal value is undefined\n     */\n    toVector(): A_SignalVector {\n        const vector: Array<A_Signal> = [];\n\n        this._state.forEach((value, key) => {\n            vector.push(value);\n        });\n\n        return new A_SignalVector(vector, this.structure);\n    }\n\n    /**\n     * Converts the current state to an object with signal constructor names as keys\n     * \n     * This provides a more readable representation of the state where each signal\n     * type is identified by its constructor name.\n     * \n     * @returns Object mapping signal constructor names to their latest values\n     * @throws Error if any signal value is undefined\n     */\n    toObject(): Record<string, A_Signal> {\n        const obj: Record<string, A_Signal> = {};\n\n        this.structure.forEach((signalConstructor) => {\n            const value = this._state.get(signalConstructor);\n            if (value === undefined) {\n                throw new Error(`Signal ${signalConstructor.name} has no value in state`);\n            }\n            obj[signalConstructor.name] = value;\n        });\n\n        return obj;\n    }\n\n}","import { A_CommonHelper, A_Context, A_Fragment, A_TYPES__Component_Constructor, A_TYPES__Entity_Constructor } from \"@adaas/a-concept\";\nimport { A_SignalConfig_Init } from \"../A-Signal.types\";\nimport { A_Signal } from \"../entities/A-Signal.entity\";\nimport { A_Frame } from \"@adaas/a-frame\";\n\n\n\n/**\n * This component should dictate a structure of the vector for all signals within a given scope.\n * so if there're multiple signals it should say what type at what position should be expected.\n * \n * e.g. [A_RouterWatcher, A_ScopeWatcher, A_LoggerWatcher]\n * This structure then should be used for any further processing of signals within the scope.\n */\n@A_Frame.Fragment({\n    namespace: 'A-Utils',\n    name: 'A-SignalConfig',\n    description: 'Signal configuration fragment that defines the structure and types of signals within a given scope. It allows specifying the expected signal constructors and their order, facilitating consistent signal management and processing across components that emit or listen to signals.'\n})\nexport class A_SignalConfig extends A_Fragment {\n\n    protected _structure?: Array<A_TYPES__Entity_Constructor<A_Signal>>;\n\n    protected _config: A_SignalConfig_Init\n\n    protected _ready?: Promise<void>;\n\n    get structure(): Array<A_TYPES__Entity_Constructor<A_Signal>> {\n        if (this._structure) {\n            return this._structure;\n        }\n\n        const scope = A_Context.scope(this);\n\n        //  just sort by constructor name to have consistent order\n        const constructors = [...scope.allowedEntities]\n            .filter(e => A_CommonHelper.isInheritedFrom(e, A_Signal))\n            .sort((a, b) => a.constructor.name.localeCompare(b.name))\n            .map(s => scope.resolveConstructor<A_Signal>(s.name));\n\n        return constructors.filter(s => s) as Array<A_TYPES__Entity_Constructor<A_Signal>>;\n    }\n\n    /**\n     * Uses for synchronization to ensure the config is initialized.\n     * \n     * @returns True if the configuration has been initialized.\n     */\n    get ready() {\n        return this._ready;\n    }\n\n    constructor(\n        params: A_SignalConfig_Init\n    ) {\n        super({ name: \"A_SignalConfig\" });\n        this._config = params;\n    }\n\n\n    /**\n     * Initializes the signal configuration if not already initialized.\n     * \n     * @returns \n     */\n    async initialize() {\n        if (!this._ready) {\n            this._ready = this._initialize();\n        }\n        return this._ready;\n    }\n\n    /**\n     * Initializes the signal configuration by processing the provided structure or string representation.\n     * This method sets up the internal structure of signal constructors based on the configuration.\n     */\n    protected async _initialize() {\n        if (this._config.structure) {\n            this._structure = this._config.structure;\n        } else if (this._config.stringStructure) {\n            const stringStructure = this._config.stringStructure.split(',').map(s => s.trim());\n            this._structure = stringStructure\n                .map(name => A_Context.scope(this).resolveConstructor<A_Signal>(name))\n                .filter(s => s);\n        }\n\n    }\n\n}","\nexport enum A_SignalBusFeatures {\n    onBeforeNext = '_A_SignalBusFeatures_onBeforeNext',\n    onNext = '_A_SignalBusFeatures_onNext',\n\n    onError = '_A_SignalBusFeatures_onError',\n}","import { A_Error } from \"@adaas/a-concept\";\n\n\n\nexport class A_SignalBusError extends A_Error {\n\n\n    static readonly SignalProcessingError = 'Signal processing error';\n}","import { A_Caller, A_Component, A_Context, A_Dependency, A_Error, A_Feature, A_Inject, A_Scope } from \"@adaas/a-concept\";\nimport { A_SignalState } from \"../context/A-SignalState.context\";\nimport { A_SignalConfig } from \"../context/A-SignalConfig.context\";\nimport { A_Signal } from \"../entities/A-Signal.entity\";\nimport { A_Config } from \"@adaas/a-utils/a-config\";\nimport { A_Logger } from \"@adaas/a-utils/a-logger\";\nimport { A_Frame } from \"@adaas/a-frame\";\nimport { A_SignalBusFeatures } from \"./A-SignalBus.constants\";\nimport { A_SignalBusError } from \"./A-SignalBus.error\";\n\n\n\n/**\n * This component should listen for all available signal watchers components in this and all parent scopes. \n * When a signal is emitted, it should forward the signal to all registered watchers.\n * \n * A_SignalBus should always return the same vector structure of the signals, and that's why it should store the state of the latest behavior. \n * For example if there are 3 watchers registered, the bus should always return a vector of 3 elements, based on the A_SignalConfig structure.\n * \n * \n * The component itself is stateless and all methods uses only parameters (context) is provided with.\n */\n@A_Frame.Component({\n    namespace: 'A-Utils',\n    name: 'A-SignalBus',\n    description: 'Signal bus component that manages the emission and state of signals within a given scope. It listens for emitted signals, updates their state, and forwards them to registered watchers. The bus ensures a consistent signal vector structure based on the defined configuration, facilitating signal management across multiple components.'\n})\nexport class A_SignalBus extends A_Component {\n\n\n    @A_Frame.Method({\n        description: 'Emit multiple signals through the signal bus.'\n    })\n    async next(...signals: A_Signal[]) {\n        const scope = new A_Scope({\n            name: `A_SignalBus-Next-Scope`,\n            entities: signals\n        })\n            .inherit(A_Context.scope(this));\n\n        try {\n            await this.call(A_SignalBusFeatures.onBeforeNext, scope);\n\n            await this.call(A_SignalBusFeatures.onNext, scope);\n\n            scope.destroy();\n\n        } catch (error) {\n\n            let wrappedError;\n\n            switch (true) {\n                case error instanceof A_SignalBusError:\n                    wrappedError = error;\n                    break;\n\n                case error instanceof A_Error && error.originalError instanceof A_SignalBusError:\n                    wrappedError = error.originalError;\n                    break;\n\n                default:\n                    wrappedError = new A_SignalBusError({\n                        title: A_SignalBusError.SignalProcessingError,\n                        description: `An error occurred while processing the signal.`,\n                        originalError: error\n                    })\n                    break;\n            }\n\n            scope.register(wrappedError);\n\n            await this.call(A_SignalBusFeatures.onError);\n\n            scope.destroy();\n        }\n    }\n\n\n    @A_Feature.Extend({\n        before: /.*/\n    })\n    protected async [A_SignalBusFeatures.onError](\n        @A_Inject(A_Error) error: A_Error,\n        @A_Inject(A_Logger) logger?: A_Logger,\n        ...args: any[]\n    ) {\n        logger?.error(error);\n    }\n\n    @A_Feature.Extend({\n        scope: [A_SignalBus],\n        before: /.*/\n    })\n    async [A_SignalBusFeatures.onBeforeNext](\n        @A_Inject(A_Scope) scope: A_Scope,\n\n        @A_Inject(A_Config) globalConfig?: A_Config<['A_SIGNAL_VECTOR_STRUCTURE']>,\n        @A_Inject(A_SignalState) state?: A_SignalState,\n\n        @A_Inject(A_Logger) logger?: A_Logger,\n        @A_Inject(A_SignalConfig) config?: A_SignalConfig,\n    ) {\n        /**\n         * We need a context where component is registered, to prevent any duplicate registrations\n         */\n        const componentContext = A_Context.scope(this);\n\n        if (!config) {\n            config = new A_SignalConfig({\n                stringStructure: globalConfig?.get('A_SIGNAL_VECTOR_STRUCTURE') || undefined\n            });\n\n            componentContext.register(config);\n        }\n\n        if (!config.ready)\n            await config.initialize();\n\n        if (!state) {\n            state = new A_SignalState(config.structure);\n            componentContext.register(state);\n        }\n    }\n\n    /**\n     * This methods extends A-Signal Emit feature to handle signal emission within the bus.\n     * \n     * It updates the signal state and emits the updated signal vector.\n     * \n     * @param signal \n     * @param globalConfig \n     * @param logger \n     * @param state \n     * @param config \n     * @returns \n     */\n    @A_Feature.Extend({\n        scope: [A_SignalBus],\n        before: /.*/\n    })\n    async [A_SignalBusFeatures.onNext](\n        @A_Dependency.Flat()\n        @A_Dependency.All()\n        @A_Inject(A_Signal) signals: A_Signal[],\n        @A_Inject(A_Scope) scope: A_Scope,\n\n        @A_Dependency.Required()\n        @A_Inject(A_SignalState) state: A_SignalState,\n\n        @A_Inject(A_Config) globalConfig?: A_Config<['A_SIGNAL_VECTOR_STRUCTURE']>,\n        @A_Inject(A_Logger) logger?: A_Logger,\n        @A_Inject(A_SignalConfig) config?: A_SignalConfig,\n    ) {\n        /*\n        1) create a signal when it occurs via new A_Signal('somedata')\n        2) emit a signal when needed via bus.next(signal)\n        3) the bus should listen for all emitted signals within the scope\n        4) when a signal is emitted, the bus should store a signal in some place (probably it's memory)\n        */\n        // const signals = scope.resolveFlatAll<A_Signal>(A_Signal);\n\n        for (const signal of signals) {\n\n            if (!state.has(signal))\n                return;\n\n            //  ------------------------------------------------------------------\n            //  And finally if all checks are passed, we can update the state\n            //  ------------------------------------------------------------------\n\n            logger?.debug(`A_SignalBus: Updating state for signal '${signal.constructor.name}' with data:`, signal.data);\n\n            state.set(signal);\n        }\n\n        const vector = state.toVector();\n\n        scope.register(vector);\n    }\n}\n"]}