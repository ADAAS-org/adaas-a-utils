{"version":3,"sources":["../../../../../src/lib/A-Signal/context/A-SignalConfig.context.ts"],"names":["A_SignalConfig","A_Fragment","A_Context","A_CommonHelper","A_Signal","A_Frame"],"mappings":";;;;;;;;;;;;;;AAmBaA,sBAAA,GAAN,6BAA6BC,mBAAA,CAAW;AAAA,EAQ3C,IAAI,SAAA,GAA0D;AAC1D,IAAA,IAAI,KAAK,UAAA,EAAY;AACjB,MAAA,OAAO,IAAA,CAAK,UAAA;AAAA,IAChB;AAEA,IAAA,MAAM,KAAA,GAAQC,kBAAA,CAAU,KAAA,CAAM,IAAI,CAAA;AAGlC,IAAA,MAAM,YAAA,GAAe,CAAC,GAAG,KAAA,CAAM,eAAe,CAAA,CACzC,MAAA,CAAO,CAAA,CAAA,KAAKC,uBAAA,CAAe,eAAA,CAAgB,CAAA,EAAGC,uBAAQ,CAAC,EACvD,IAAA,CAAK,CAAC,CAAA,EAAG,CAAA,KAAM,CAAA,CAAE,WAAA,CAAY,IAAA,CAAK,aAAA,CAAc,EAAE,IAAI,CAAC,CAAA,CACvD,GAAA,CAAI,CAAA,CAAA,KAAK,KAAA,CAAM,kBAAA,CAA6B,CAAA,CAAE,IAAI,CAAC,CAAA;AAExD,IAAA,OAAO,YAAA,CAAa,MAAA,CAAO,CAAA,CAAA,KAAK,CAAC,CAAA;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,KAAA,GAAQ;AACR,IAAA,OAAO,IAAA,CAAK,MAAA;AAAA,EAChB;AAAA,EAEA,YACI,MAAA,EACF;AACE,IAAA,KAAA,CAAM,EAAE,IAAA,EAAM,gBAAA,EAAkB,CAAA;AAChC,IAAA,IAAA,CAAK,OAAA,GAAU,MAAA;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,UAAA,GAAa;AACf,IAAA,IAAI,CAAC,KAAK,MAAA,EAAQ;AACd,MAAA,IAAA,CAAK,MAAA,GAAS,KAAK,WAAA,EAAY;AAAA,IACnC;AACA,IAAA,OAAO,IAAA,CAAK,MAAA;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAgB,WAAA,GAAc;AAC1B,IAAA,IAAI,IAAA,CAAK,QAAQ,SAAA,EAAW;AACxB,MAAA,IAAA,CAAK,UAAA,GAAa,KAAK,OAAA,CAAQ,SAAA;AAAA,IACnC,CAAA,MAAA,IAAW,IAAA,CAAK,OAAA,CAAQ,eAAA,EAAiB;AACrC,MAAA,MAAM,eAAA,GAAkB,IAAA,CAAK,OAAA,CAAQ,eAAA,CAAgB,KAAA,CAAM,GAAG,CAAA,CAAE,GAAA,CAAI,CAAA,CAAA,KAAK,CAAA,CAAE,IAAA,EAAM,CAAA;AACjF,MAAA,IAAA,CAAK,UAAA,GAAa,eAAA,CACb,GAAA,CAAI,CAAA,IAAA,KAAQF,mBAAU,KAAA,CAAM,IAAI,CAAA,CAAE,kBAAA,CAA6B,IAAI,CAAC,CAAA,CACpE,MAAA,CAAO,OAAK,CAAC,CAAA;AAAA,IACtB;AAAA,EAEJ;AAEJ;AArEaF,sBAAA,GAAN,eAAA,CAAA;AAAA,EALNK,eAAQ,QAAA,CAAS;AAAA,IACd,SAAA,EAAW,SAAA;AAAA,IACX,IAAA,EAAM,gBAAA;AAAA,IACN,WAAA,EAAa;AAAA,GAChB;AAAA,CAAA,EACYL,sBAAA,CAAA","file":"A-SignalConfig.context.js","sourcesContent":["import { A_CommonHelper, A_Context, A_Fragment, A_TYPES__Component_Constructor, A_TYPES__Entity_Constructor } from \"@adaas/a-concept\";\nimport { A_SignalConfig_Init } from \"../A-Signal.types\";\nimport { A_Signal } from \"../entities/A-Signal.entity\";\nimport { A_Frame } from \"@adaas/a-frame\";\n\n\n\n/**\n * This component should dictate a structure of the vector for all signals within a given scope.\n * so if there're multiple signals it should say what type at what position should be expected.\n * \n * e.g. [A_RouterWatcher, A_ScopeWatcher, A_LoggerWatcher]\n * This structure then should be used for any further processing of signals within the scope.\n */\n@A_Frame.Fragment({\n    namespace: 'A-Utils',\n    name: 'A-SignalConfig',\n    description: 'Signal configuration fragment that defines the structure and types of signals within a given scope. It allows specifying the expected signal constructors and their order, facilitating consistent signal management and processing across components that emit or listen to signals.'\n})\nexport class A_SignalConfig extends A_Fragment {\n\n    protected _structure?: Array<A_TYPES__Entity_Constructor<A_Signal>>;\n\n    protected _config: A_SignalConfig_Init\n\n    protected _ready?: Promise<void>;\n\n    get structure(): Array<A_TYPES__Entity_Constructor<A_Signal>> {\n        if (this._structure) {\n            return this._structure;\n        }\n\n        const scope = A_Context.scope(this);\n\n        //  just sort by constructor name to have consistent order\n        const constructors = [...scope.allowedEntities]\n            .filter(e => A_CommonHelper.isInheritedFrom(e, A_Signal))\n            .sort((a, b) => a.constructor.name.localeCompare(b.name))\n            .map(s => scope.resolveConstructor<A_Signal>(s.name));\n\n        return constructors.filter(s => s) as Array<A_TYPES__Entity_Constructor<A_Signal>>;\n    }\n\n    /**\n     * Uses for synchronization to ensure the config is initialized.\n     * \n     * @returns True if the configuration has been initialized.\n     */\n    get ready() {\n        return this._ready;\n    }\n\n    constructor(\n        params: A_SignalConfig_Init\n    ) {\n        super({ name: \"A_SignalConfig\" });\n        this._config = params;\n    }\n\n\n    /**\n     * Initializes the signal configuration if not already initialized.\n     * \n     * @returns \n     */\n    async initialize() {\n        if (!this._ready) {\n            this._ready = this._initialize();\n        }\n        return this._ready;\n    }\n\n    /**\n     * Initializes the signal configuration by processing the provided structure or string representation.\n     * This method sets up the internal structure of signal constructors based on the configuration.\n     */\n    protected async _initialize() {\n        if (this._config.structure) {\n            this._structure = this._config.structure;\n        } else if (this._config.stringStructure) {\n            const stringStructure = this._config.stringStructure.split(',').map(s => s.trim());\n            this._structure = stringStructure\n                .map(name => A_Context.scope(this).resolveConstructor<A_Signal>(name))\n                .filter(s => s);\n        }\n\n    }\n\n}"]}