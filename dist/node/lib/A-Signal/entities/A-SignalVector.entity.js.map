{"version":3,"sources":["../../../../../src/lib/A-Signal/entities/A-SignalVector.entity.ts"],"names":["A_SignalVector","A_Entity","A_Frame"],"mappings":"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","file":"A-SignalVector.entity.js","sourcesContent":["import { A_Entity, A_Scope, A_TYPES__Component_Constructor, A_TYPES__Entity_Constructor } from \"@adaas/a-concept\";\nimport { A_SignalVector_Serialized, A_SignalVector_Init, A_Signal_TSignalsConstructors, A_SignalTValue, A_SignalTValueArray } from \"../A-Signal.types\";\nimport { A_Signal } from \"./A-Signal.entity\";\nimport { A_Frame } from \"@adaas/a-frame\";\n\n\n/**\n * A Signal Vector Entity is a collection of signals structured in a specific way.\n * It allows grouping multiple signals together for batch processing or transmission.\n * \n * Signal Vectors are useful in scenarios where multiple related signals need to be handled together,\n * as a state of the system or a snapshot of various parameters at a given time.\n * \n * @template TSignalsConstructors - Array of signal constructor types (e.g., [typeof MySignal, typeof CustomSignal])\n * @template TSignals - Array of signal instances derived from constructors\n */\n@A_Frame.Entity({\n    namespace: 'A-Utils',\n    name: 'A-SignalVector',\n    description: 'A Signal Vector Entity represents a collection of signals structured in a specific way, allowing for batch processing and transmission of related signals as a unified state representation.'\n})\nexport class A_SignalVector<\n    TSignals extends A_Signal[] = A_Signal[],\n> extends A_Entity<A_SignalVector_Init<TSignals>> {\n\n    /**\n     * The structure of the signal vector, defining the types of signals it contains.\n     * \n     * For example:\n     * [UserSignInSignal, UserStatusSignal, UserActivitySignal]\n     * \n     * [!] if not provided, it will be derived from the signals values.\n     */\n    protected _structure?: A_Signal_TSignalsConstructors<TSignals>;\n    /**\n     * It's actual vector Values of Signals like :\n     * [UserActionSignal, UserMousePositionSignal, ExternalDependencySignal]\n     */\n    protected _signals!: TSignals\n\n    constructor(values: TSignals, structure?: { [K in keyof TSignals]: TSignals[K] extends A_Signal ? A_TYPES__Entity_Constructor<TSignals[K]> : never })\n    constructor(serialized: A_SignalVector_Serialized)\n    constructor(param1: TSignals | A_SignalVector_Serialized, param2?: A_Signal_TSignalsConstructors<TSignals>) {\n\n        if ('aseid' in param1) {\n            // Handle serialized case\n            super(param1 as A_SignalVector_Serialized);\n        } else {\n            // Handle init case  \n            super({\n                structure: param2 ? param2 : (param1 as TSignals).map(s => s.constructor as A_TYPES__Entity_Constructor<TSignals[number]>) as A_Signal_TSignalsConstructors<TSignals>,\n                values: param1 as TSignals\n            } as A_SignalVector_Init<TSignals>);\n        }\n    }\n\n\n    fromNew(newEntity: A_SignalVector_Init<TSignals>): void {\n        super.fromNew(newEntity);\n        this._structure = newEntity.structure;\n        this._signals = newEntity.values;\n    }\n\n    /**\n     * The structure of the signal vector, defining the types of signals it contains.\n     * \n     * For example:\n     * [UserSignInSignal, UserStatusSignal, UserActivitySignal]\n     * \n     */\n    get structure(): A_Signal_TSignalsConstructors<TSignals> {\n        return this._structure || this._signals.map(s => s.constructor as A_TYPES__Entity_Constructor<TSignals[number]>) as A_Signal_TSignalsConstructors<TSignals>;\n    }\n\n\n    get length(): number {\n        return this.structure.length;\n    }\n\n\n    /**\n     * Enables iteration over the signals in the vector.\n     * \n     * @returns \n     */\n    [Symbol.iterator](): Iterator<TSignals[number]> {\n        let pointer = 0;\n        const signals = this.structure.map((signalConstructor) => {\n            const signalIndex = this._signals.findIndex(s => s.constructor === signalConstructor);\n            return signalIndex !== -1 ? this._signals[signalIndex] : undefined;\n        }) as TSignals[number][];\n\n        return {\n            next(): IteratorResult<TSignals[number]> {\n                if (pointer < signals.length) {\n                    return {\n                        done: false,\n                        value: signals[pointer++]\n                    };\n                } else {\n                    return {\n                        done: true,\n                        value: undefined as any\n                    };\n                }\n            }\n        };\n    }\n\n\n    /**\n     * Allows to match the current Signal Vector with another Signal Vector by comparing each signal in the structure.\n     * This method returns true if all signals in the vector match the corresponding signals in the other vector.\n     * \n     * @param other \n     * @returns \n     */\n    match(other: A_SignalVector<TSignals>): boolean {\n        if (this.length !== other.length) {\n            return false;\n        }\n\n        for (let i = 0; i < this.length; i++) {\n            const thisSignalConstructor = this.structure[i];\n            const otherSignalConstructor = other.structure[i];\n\n            if (thisSignalConstructor !== otherSignalConstructor) {\n                return false;\n            }\n\n            const thisSignalIndex = this._signals.findIndex(s => s.constructor === thisSignalConstructor);\n            const otherSignalIndex = other._signals.findIndex(s => s.constructor === otherSignalConstructor);\n\n            const thisSignal = thisSignalIndex !== -1 ? this._signals[thisSignalIndex] : undefined;\n            const otherSignal = otherSignalIndex !== -1 ? other._signals[otherSignalIndex] : undefined;\n\n            if (thisSignal && otherSignal) {\n                if (!thisSignal.compare(otherSignal)) {\n                    return false;\n                }\n            } else if (thisSignal || otherSignal) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \n    /**\n     * This method should ensure that the current Signal Vector contains all signals from the provided Signal Vector.\n     * \n     * @param signal \n     */\n    contains(signal: A_SignalVector): boolean{\n        for (const signalConstructor of signal.structure) {\n            const signalIndex = this._signals.findIndex(s => s.constructor === signalConstructor);\n            if (signalIndex === -1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks if the vector contains a signal of the specified type.\n     * \n     * @param signal \n     */\n    has(signal: A_Signal): boolean\n    has(signalConstructor: A_TYPES__Entity_Constructor<A_Signal>): boolean\n    has(param1: A_Signal | A_TYPES__Entity_Constructor<A_Signal>): boolean {\n        let signalConstructor: A_TYPES__Entity_Constructor<A_Signal>;\n        if (param1 instanceof A_Entity) {\n            signalConstructor = param1.constructor as A_TYPES__Entity_Constructor<A_Signal>;\n        } else {\n            signalConstructor = param1;\n        }\n        return this.structure.includes(signalConstructor as any);\n    }\n\n    /**\n     * Retrieves the signal of the specified type from the vector.\n     * \n     * @param signal \n     */\n    get<T extends A_Signal>(signal: T): T | undefined\n    get<T extends A_Signal>(signalConstructor: A_TYPES__Entity_Constructor<T>): T | undefined\n    get<T extends A_Signal>(param1: T | A_TYPES__Entity_Constructor<T>): T | undefined {\n        let signalConstructor: A_TYPES__Entity_Constructor<A_Signal>;\n\n        if (param1 instanceof A_Entity) {\n            signalConstructor = param1.constructor as A_TYPES__Entity_Constructor<A_Signal>;\n        } else {\n            signalConstructor = param1 as A_TYPES__Entity_Constructor<A_Signal>;\n        }\n\n        const index = this._signals.findIndex(s => s.constructor === signalConstructor);\n        if (index === -1) {\n            return undefined;\n        }\n        return this._signals[index] as T;\n    }\n\n\n    /**\n     * Converts to Array of values of signals in the vector\n     * Maintains the order specified in the structure/generic type\n     * \n     * @param structure - Optional structure to override the default ordering\n     * @returns Array of signal instances in the specified order\n     */\n    async toVector<\n        T extends Array<A_Signal> = TSignals,\n    >(\n        structure?: A_Signal_TSignalsConstructors<T>\n    ): Promise<T> {\n        const usedStructure = structure || this.structure;\n\n        return usedStructure.map((signalConstructor) => {\n            const signalIndex = this._signals.findIndex(s => s.constructor === signalConstructor);\n            return signalIndex !== -1 ? this._signals[signalIndex] : undefined;\n        }) as T;\n    }\n\n\n    /**\n     * Converts to Array of data of signals in the vector\n     * Maintains the order specified in the structure/generic type\n     * \n     * @param structure - Optional structure to override the default ordering\n     * @returns Array of serialized signal data in the specified order\n     */\n    async toDataVector<\n        T extends A_Signal[] = TSignals,\n    >(\n        structure?: A_Signal_TSignalsConstructors<T>\n    ): Promise<A_SignalTValueArray<T>> {\n\n        const usedStructure = structure || this.structure;\n\n        const results: Array<any> = [];\n\n        for (const signalConstructor of usedStructure) {\n            const signalIndex = this._signals.findIndex(s => s.constructor === signalConstructor);\n            let data: any;\n            if (signalIndex === -1) {\n\n                data = await (signalConstructor as typeof A_Signal).default()\n\n            } else {\n                const signal = this._signals[signalIndex];\n                data = signal;\n            }\n\n\n            results.push(data?.toJSON().data);\n        }\n\n        return results as A_SignalTValueArray<T>;\n    }\n\n    /**\n     * Converts to Object with signal constructor names as keys and their corresponding data values\n     * Uses the structure ordering to ensure consistent key ordering\n     * \n     * @returns Object with signal constructor names as keys and signal data as values\n     */\n    async toObject<\n        T extends Array<A_Signal> = TSignals,\n    >(\n        structure?: { [K in keyof T]: T[K] extends A_Signal ? A_TYPES__Entity_Constructor<T[K]> : never }\n    ): Promise<{ [key: string]: T[number] extends A_Signal<infer D> ? D | undefined : never }> {\n\n        const usedStructure = structure || this.structure;\n\n        const obj: { [key: string]: T[number] extends A_Signal<infer D> ? D | undefined : never } = {};\n        usedStructure.forEach((signalConstructor) => {\n            const signalName = signalConstructor.name;\n            const signalIndex = this._signals.findIndex(s => s.constructor === signalConstructor);\n\n            if (signalIndex !== -1) {\n                const signal = this._signals[signalIndex];\n                obj[signalName] = signal.toJSON().data as any;\n            } else {\n                obj[signalName] = undefined as any;\n            }\n        });\n\n        return obj;\n    }\n\n\n    /**\n     * Serializes the Signal Vector to a JSON-compatible format.\n     * \n     * \n     * @returns \n     */\n    toJSON(): A_SignalVector_Serialized {\n        return {\n            ...super.toJSON(),\n            structure: this.structure.map(s => s.name),\n            values: this._signals.map(s => s.toJSON())\n        };\n    }\n}\n"]}