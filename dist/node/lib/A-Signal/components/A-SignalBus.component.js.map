{"version":3,"sources":["../../../../../src/lib/A-Signal/components/A-SignalBus.component.ts"],"names":["A_SignalBus","A_Component","A_Scope","A_Context","A_SignalBusFeatures","A_SignalBusError","A_Error","A_SignalConfig","A_SignalState","A_Frame","A_Feature","A_Logger","A_Config","A_Signal"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA;AA2BaA,mBAAA,GAAN,0BAA0BC,oBAAA,CAAY;AAAA,EAMzC,MAAM,QAAQ,OAAA,EAAqB;AAC/B,IAAA,MAAM,KAAA,GAAQ,IAAIC,gBAAA,CAAQ;AAAA,MACtB,IAAA,EAAM,CAAA,sBAAA,CAAA;AAAA,MACN,QAAA,EAAU;AAAA,KACb,CAAA,CACI,OAAA,CAAQC,kBAAA,CAAU,KAAA,CAAM,IAAI,CAAC,CAAA;AAElC,IAAA,IAAI;AACA,MAAA,MAAM,IAAA,CAAK,IAAA,CAAKC,wCAAA,CAAoB,YAAA,EAAc,KAAK,CAAA;AAEvD,MAAA,MAAM,IAAA,CAAK,IAAA,CAAKA,wCAAA,CAAoB,MAAA,EAAQ,KAAK,CAAA;AAEjD,MAAA,KAAA,CAAM,OAAA,EAAQ;AAAA,IAElB,SAAS,KAAA,EAAO;AAEZ,MAAA,IAAI,YAAA;AAEJ,MAAA,QAAQ,IAAA;AAAM,QACV,KAAK,KAAA,YAAiBC,iCAAA;AAClB,UAAA,YAAA,GAAe,KAAA;AACf,UAAA;AAAA,QAEJ,MAAK,KAAA,YAAiBC,gBAAA,IAAW,KAAA,CAAM,aAAA,YAAyBD,iCAAA;AAC5D,UAAA,YAAA,GAAe,KAAA,CAAM,aAAA;AACrB,UAAA;AAAA,QAEJ;AACI,UAAA,YAAA,GAAe,IAAIA,iCAAA,CAAiB;AAAA,YAChC,OAAOA,iCAAA,CAAiB,qBAAA;AAAA,YACxB,WAAA,EAAa,CAAA,8CAAA,CAAA;AAAA,YACb,aAAA,EAAe;AAAA,WAClB,CAAA;AACD,UAAA;AAAA;AAGR,MAAA,KAAA,CAAM,SAAS,YAAY,CAAA;AAE3B,MAAA,MAAM,IAAA,CAAK,IAAA,CAAKD,wCAAA,CAAoB,OAAO,CAAA;AAE3C,MAAA,KAAA,CAAM,OAAA,EAAQ;AAAA,IAClB;AAAA,EACJ;AAAA,EAMA,OAAiB,EAAA,GAAAA,wCAAA,CAAoB,OAAO,CAAA,CACrB,KAAA,EACC,WACjB,IAAA,EACL;AACE,IAAA,MAAA,EAAQ,MAAM,KAAK,CAAA;AAAA,EACvB;AAAA,EAMA,OAAO,8CAAoB,YAAY,CAAA,CAChB,OAEC,YAAA,EACK,KAAA,EAEL,QACM,MAAA,EAC5B;AAIE,IAAA,MAAM,gBAAA,GAAmBD,kBAAA,CAAU,KAAA,CAAM,IAAI,CAAA;AAE7C,IAAA,IAAI,CAAC,MAAA,EAAQ;AACT,MAAA,MAAA,GAAS,IAAII,oCAAA,CAAe;AAAA,QACxB,eAAA,EAAiB,YAAA,EAAc,GAAA,CAAI,2BAA2B,CAAA,IAAK;AAAA,OACtE,CAAA;AAED,MAAA,gBAAA,CAAiB,SAAS,MAAM,CAAA;AAAA,IACpC;AAEA,IAAA,IAAI,CAAC,MAAA,CAAO,KAAA;AACR,MAAA,MAAM,OAAO,UAAA,EAAW;AAE5B,IAAA,IAAI,CAAC,KAAA,EAAO;AACR,MAAA,KAAA,GAAQ,IAAIC,kCAAA,CAAc,MAAA,CAAO,SAAS,CAAA;AAC1C,MAAA,gBAAA,CAAiB,SAAS,KAAK,CAAA;AAAA,IACnC;AAAA,EACJ;AAAA,EAkBA,OAAO,8CAAoB,MAAM,CAAA,CAGT,SACD,KAAA,EAGM,KAAA,EAEL,YAAA,EACA,MAAA,EACM,MAAA,EAC5B;AASE,IAAA,KAAA,MAAW,UAAU,OAAA,EAAS;AAE1B,MAAA,IAAI,CAAC,KAAA,CAAM,GAAA,CAAI,MAAM,CAAA;AACjB,QAAA;AAMJ,MAAA,MAAA,EAAQ,MAAM,CAAA,wCAAA,EAA2C,MAAA,CAAO,YAAY,IAAI,CAAA,YAAA,CAAA,EAAgB,OAAO,IAAI,CAAA;AAE3G,MAAA,KAAA,CAAM,IAAI,MAAM,CAAA;AAAA,IACpB;AAEA,IAAA,MAAM,MAAA,GAAS,MAAM,QAAA,EAAS;AAE9B,IAAA,KAAA,CAAM,SAAS,MAAM,CAAA;AAAA,EACzB;AACJ;AAlJU,eAAA,CAAA;AAAA,EAHLC,eAAQ,MAAA,CAAO;AAAA,IACZ,WAAA,EAAa;AAAA,GAChB;AAAA,CAAA,EALQT,mBAAA,CAMH,SAAA,EAAA,MAAA,EAAA,CAAA,CAAA;AAgDW,eAAA,CAAA;AAAA,EAHhBU,mBAAU,MAAA,CAAO;AAAA,IACd,MAAA,EAAQ;AAAA,GACX,CAAA;AAAA,EAEI,qCAASJ,gBAAO,CAAA,CAAA;AAAA,EAChB,qCAASK,gBAAQ,CAAA;AAAA,CAAA,EAxDbX,mBAAA,CAsDQ,SAAA,EAAA,EAAA,EAAA,CAAA,CAAA;AAYV,eAAA,CAAA;AAAA,EAJNU,mBAAU,MAAA,CAAO;AAAA,IACd,KAAA,EAAO,CAACV,mBAAW,CAAA;AAAA,IACnB,MAAA,EAAQ;AAAA,GACX,CAAA;AAAA,EAEI,qCAASE,gBAAO,CAAA,CAAA;AAAA,EAEhB,qCAASU,gBAAQ,CAAA,CAAA;AAAA,EACjB,qCAASJ,kCAAa,CAAA,CAAA;AAAA,EAEtB,qCAASG,gBAAQ,CAAA,CAAA;AAAA,EACjB,qCAASJ,oCAAc,CAAA;AAAA,CAAA,EAzEnBP,mBAAA,CAkEF,SAAA,EAAA,EAAA,EAAA,CAAA,CAAA;AA+CA,eAAA,CAAA;AAAA,EAJNU,mBAAU,MAAA,CAAO;AAAA,IACd,KAAA,EAAO,CAACV,mBAAW,CAAA;AAAA,IACnB,MAAA,EAAQ;AAAA,GACX,CAAA;AAAA,EAEI,yCAAa,IAAA,EAAK,CAAA;AAAA,EAClB,yCAAa,GAAA,EAAI,CAAA;AAAA,EACjB,qCAASa,uBAAQ,CAAA,CAAA;AAAA,EACjB,qCAASX,gBAAO,CAAA,CAAA;AAAA,EAEhB,yCAAa,QAAA,EAAS,CAAA;AAAA,EACtB,qCAASM,kCAAa,CAAA,CAAA;AAAA,EAEtB,qCAASI,gBAAQ,CAAA,CAAA;AAAA,EACjB,qCAASD,gBAAQ,CAAA,CAAA;AAAA,EACjB,qCAASJ,oCAAc,CAAA;AAAA,CAAA,EA5HnBP,mBAAA,CAiHF,SAAA,EAAA,EAAA,EAAA,CAAA,CAAA;AAjHEA,mBAAA,GAAN,eAAA,CAAA;AAAA,EALNS,eAAQ,SAAA,CAAU;AAAA,IACf,SAAA,EAAW,SAAA;AAAA,IACX,IAAA,EAAM,aAAA;AAAA,IACN,WAAA,EAAa;AAAA,GAChB;AAAA,CAAA,EACYT,mBAAA,CAAA","file":"A-SignalBus.component.js","sourcesContent":["import { A_Caller, A_Component, A_Context, A_Dependency, A_Error, A_Feature, A_Inject, A_Scope } from \"@adaas/a-concept\";\nimport { A_SignalState } from \"../context/A-SignalState.context\";\nimport { A_SignalConfig } from \"../context/A-SignalConfig.context\";\nimport { A_Signal } from \"../entities/A-Signal.entity\";\nimport { A_Config } from \"@adaas/a-utils/a-config\";\nimport { A_Logger } from \"@adaas/a-utils/a-logger\";\nimport { A_Frame } from \"@adaas/a-frame\";\nimport { A_SignalBusFeatures } from \"./A-SignalBus.constants\";\nimport { A_SignalBusError } from \"./A-SignalBus.error\";\n\n\n\n/**\n * This component should listen for all available signal watchers components in this and all parent scopes. \n * When a signal is emitted, it should forward the signal to all registered watchers.\n * \n * A_SignalBus should always return the same vector structure of the signals, and that's why it should store the state of the latest behavior. \n * For example if there are 3 watchers registered, the bus should always return a vector of 3 elements, based on the A_SignalConfig structure.\n * \n * \n * The component itself is stateless and all methods uses only parameters (context) is provided with.\n */\n@A_Frame.Component({\n    namespace: 'A-Utils',\n    name: 'A-SignalBus',\n    description: 'Signal bus component that manages the emission and state of signals within a given scope. It listens for emitted signals, updates their state, and forwards them to registered watchers. The bus ensures a consistent signal vector structure based on the defined configuration, facilitating signal management across multiple components.'\n})\nexport class A_SignalBus extends A_Component {\n\n\n    @A_Frame.Method({\n        description: 'Emit multiple signals through the signal bus.'\n    })\n    async next(...signals: A_Signal[]) {\n        const scope = new A_Scope({\n            name: `A_SignalBus-Next-Scope`,\n            entities: signals\n        })\n            .inherit(A_Context.scope(this));\n\n        try {\n            await this.call(A_SignalBusFeatures.onBeforeNext, scope);\n\n            await this.call(A_SignalBusFeatures.onNext, scope);\n\n            scope.destroy();\n\n        } catch (error) {\n\n            let wrappedError;\n\n            switch (true) {\n                case error instanceof A_SignalBusError:\n                    wrappedError = error;\n                    break;\n\n                case error instanceof A_Error && error.originalError instanceof A_SignalBusError:\n                    wrappedError = error.originalError;\n                    break;\n\n                default:\n                    wrappedError = new A_SignalBusError({\n                        title: A_SignalBusError.SignalProcessingError,\n                        description: `An error occurred while processing the signal.`,\n                        originalError: error\n                    })\n                    break;\n            }\n\n            scope.register(wrappedError);\n\n            await this.call(A_SignalBusFeatures.onError);\n\n            scope.destroy();\n        }\n    }\n\n\n    @A_Feature.Extend({\n        before: /.*/\n    })\n    protected async [A_SignalBusFeatures.onError](\n        @A_Inject(A_Error) error: A_Error,\n        @A_Inject(A_Logger) logger?: A_Logger,\n        ...args: any[]\n    ) {\n        logger?.error(error);\n    }\n\n    @A_Feature.Extend({\n        scope: [A_SignalBus],\n        before: /.*/\n    })\n    async [A_SignalBusFeatures.onBeforeNext](\n        @A_Inject(A_Scope) scope: A_Scope,\n\n        @A_Inject(A_Config) globalConfig?: A_Config<['A_SIGNAL_VECTOR_STRUCTURE']>,\n        @A_Inject(A_SignalState) state?: A_SignalState,\n\n        @A_Inject(A_Logger) logger?: A_Logger,\n        @A_Inject(A_SignalConfig) config?: A_SignalConfig,\n    ) {\n        /**\n         * We need a context where component is registered, to prevent any duplicate registrations\n         */\n        const componentContext = A_Context.scope(this);\n\n        if (!config) {\n            config = new A_SignalConfig({\n                stringStructure: globalConfig?.get('A_SIGNAL_VECTOR_STRUCTURE') || undefined\n            });\n\n            componentContext.register(config);\n        }\n\n        if (!config.ready)\n            await config.initialize();\n\n        if (!state) {\n            state = new A_SignalState(config.structure);\n            componentContext.register(state);\n        }\n    }\n\n    /**\n     * This methods extends A-Signal Emit feature to handle signal emission within the bus.\n     * \n     * It updates the signal state and emits the updated signal vector.\n     * \n     * @param signal \n     * @param globalConfig \n     * @param logger \n     * @param state \n     * @param config \n     * @returns \n     */\n    @A_Feature.Extend({\n        scope: [A_SignalBus],\n        before: /.*/\n    })\n    async [A_SignalBusFeatures.onNext](\n        @A_Dependency.Flat()\n        @A_Dependency.All()\n        @A_Inject(A_Signal) signals: A_Signal[],\n        @A_Inject(A_Scope) scope: A_Scope,\n\n        @A_Dependency.Required()\n        @A_Inject(A_SignalState) state: A_SignalState,\n\n        @A_Inject(A_Config) globalConfig?: A_Config<['A_SIGNAL_VECTOR_STRUCTURE']>,\n        @A_Inject(A_Logger) logger?: A_Logger,\n        @A_Inject(A_SignalConfig) config?: A_SignalConfig,\n    ) {\n        /*\n        1) create a signal when it occurs via new A_Signal('somedata')\n        2) emit a signal when needed via bus.next(signal)\n        3) the bus should listen for all emitted signals within the scope\n        4) when a signal is emitted, the bus should store a signal in some place (probably it's memory)\n        */\n        // const signals = scope.resolveFlatAll<A_Signal>(A_Signal);\n\n        for (const signal of signals) {\n\n            if (!state.has(signal))\n                return;\n\n            //  ------------------------------------------------------------------\n            //  And finally if all checks are passed, we can update the state\n            //  ------------------------------------------------------------------\n\n            logger?.debug(`A_SignalBus: Updating state for signal '${signal.constructor.name}' with data:`, signal.data);\n\n            state.set(signal);\n        }\n\n        const vector = state.toVector();\n\n        scope.register(vector);\n    }\n}\n"]}