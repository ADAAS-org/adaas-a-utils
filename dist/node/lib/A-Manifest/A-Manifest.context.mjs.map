{"version":3,"sources":["../../../../src/lib/A-Manifest/A-Manifest.context.ts"],"names":[],"mappings":"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","file":"A-Manifest.context.mjs","sourcesContent":["import { A_Component, A_Fragment, A_TypeGuards, A_TYPES__Component_Constructor } from \"@adaas/a-concept\";\nimport { A_UTILS_TYPES__Manifest_Init, A_UTILS_TYPES__Manifest_ComponentLevelConfig, A_UTILS_TYPES__Manifest_AllowedComponents, A_UTILS_TYPES__ManifestRule, A_UTILS_TYPES__ManifestQuery } from \"./A-Manifest.types\";\nimport { A_ManifestError } from \"./A-Manifest.error\";\nimport { A_ManifestChecker } from \"./classes/A-ManifestChecker.class\";\nimport { A_Frame } from \"@adaas/a-frame\";\n\n\n\n\n\n@A_Frame.Fragment({\n    namespace: 'A-Utils',\n    name: 'A-Manifest',\n    description: 'A-Manifest is a configuration fragment that allows to include or exclude component application for particular methods. It provides fine-grained control over which components are applied to which targets and methods within the application, enabling flexible and dynamic behavior based on defined rules.'\n})\nexport class A_Manifest extends A_Fragment {\n\n    private rules: A_UTILS_TYPES__ManifestRule[] = [];\n\n    /**\n     * A-Manifest is a configuration set that allows to include or exclude component application for the particular methods.\n     *\n     * For example, if A-Scope provides polymorphic A-Component that applies for All A-Entities in it but you have another component that should be used for only One particular Entity, you can use A-Manifest to specify this behavior.\n     * \n     * \n     * By default if Component is provided in the scope - it applies for all entities in it. However, if you want to exclude some entities or include only some entities for the particular component - you can use A-Manifest to define this behavior.\n     * \n     * @param config - Array of component configurations\n     */\n    constructor(config: A_UTILS_TYPES__Manifest_Init = []) {\n        super({\n            name: 'A-Manifest',\n        });\n\n        this.prepare(config);\n    }\n\n\n    /**\n     * Should convert received configuration into internal Regexp applicable for internal storage\n     */\n    protected prepare(config: A_UTILS_TYPES__Manifest_Init) {\n        if (!A_TypeGuards.isArray(config))\n            throw new A_ManifestError(\n                A_ManifestError.ManifestInitializationError,\n                `A-Manifest configuration should be an array of configurations`\n            );\n\n        for (const item of config) {\n            this.processConfigItem(item);\n        }\n    }\n\n    /**\n     * Process a single configuration item and convert it to internal rules\n     */\n    private processConfigItem(item: A_UTILS_TYPES__Manifest_ComponentLevelConfig) {\n        if (!A_TypeGuards.isComponentConstructor(item.component))\n            throw new A_ManifestError(\n                A_ManifestError.ManifestInitializationError,\n                `A-Manifest configuration item should be a A-Component constructor`\n            );\n\n        const componentRegex = this.constructorToRegex(item.component);\n\n        // Always add component-level rule first (applies to all methods)\n        if (item.apply || item.exclude) {\n            const methodRegex = /.*/; // Match all methods\n\n            this.rules.push({\n                componentRegex,\n                methodRegex,\n                applyRegex: item.apply ? this.allowedComponentsToRegex(item.apply) : undefined,\n                excludeRegex: item.exclude ? this.allowedComponentsToRegex(item.exclude) : undefined,\n            });\n        }\n\n        // Then add method-level configurations (these will override component-level)\n        if (item.methods && item.methods.length > 0) {\n            for (const methodConfig of item.methods) {\n                const methodRegex = this.methodToRegex(methodConfig.method);\n\n                this.rules.push({\n                    componentRegex,\n                    methodRegex,\n                    applyRegex: methodConfig.apply ? this.allowedComponentsToRegex(methodConfig.apply) : undefined,\n                    excludeRegex: methodConfig.exclude ? this.allowedComponentsToRegex(methodConfig.exclude) : undefined,\n                });\n            }\n        }\n    }\n\n\n\n    /**\n     * Convert a constructor to a regex pattern\n     */\n    private constructorToRegex(ctor: A_TYPES__Component_Constructor): RegExp {\n        return new RegExp(`^${this.escapeRegex(ctor.name)}$`);\n    }\n\n    /**\n     * Convert a method name or regex to a regex pattern\n     */\n    private methodToRegex(method: string | RegExp): RegExp {\n        if (method instanceof RegExp) {\n            return method;\n        }\n        return new RegExp(`^${this.escapeRegex(method as string)}$`);\n    }\n\n    /**\n     * Convert allowed components array or regex to a single regex\n     */\n    private allowedComponentsToRegex(components: A_UTILS_TYPES__Manifest_AllowedComponents[] | RegExp): RegExp {\n        if (components instanceof RegExp) {\n            return components;\n        }\n\n        const patterns = components.map(ctor => this.escapeRegex(ctor.name));\n        return new RegExp(`^(${patterns.join('|')})$`);\n    }\n\n    /**\n     * Escape special regex characters in a string\n     */\n    private escapeRegex(str: string): string {\n        return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    }\n\n    protected configItemToRegexp(item: A_TYPES__Component_Constructor): RegExp {\n        return this.constructorToRegex(item);\n    }\n\n\n    protected ID(component: A_TYPES__Component_Constructor, method: string) {\n        return `${component.name}.${method}`;\n    }\n\n    /**\n     * Check if a component and method combination is allowed for a target\n     */\n    isAllowed<T extends A_Component>(\n        ctor: T | A_TYPES__Component_Constructor<T>,\n        method: string\n    ): A_ManifestChecker {\n        const componentCtor = typeof ctor === 'function' ? ctor : ctor.constructor as A_TYPES__Component_Constructor;\n        return new A_ManifestChecker(this, componentCtor, method);\n    }\n\n    /**\n     * Internal method to check if access is allowed\n     */\n    internal_checkAccess(query: A_UTILS_TYPES__ManifestQuery): boolean {\n        const componentName = query.component.name;\n        const methodName = query.method;\n        const targetName = query.target.name;\n\n        // Find matching rules, sorted by specificity (method-specific rules first)\n        const matchingRules = this.rules\n            .filter(rule =>\n                rule.componentRegex.test(componentName) &&\n                rule.methodRegex.test(methodName)\n            )\n            .sort((a, b) => {\n                // Method-specific rules (not .* pattern) should come before general rules\n                const aIsGeneral = a.methodRegex.source === '.*';\n                const bIsGeneral = b.methodRegex.source === '.*';\n\n                if (aIsGeneral && !bIsGeneral) return 1;  // b comes first\n                if (!aIsGeneral && bIsGeneral) return -1; // a comes first\n                return 0; // same priority\n            });\n\n        // If no rules match, allow by default\n        if (matchingRules.length === 0) {\n            return true;\n        }\n\n        // Process rules in order of specificity (most specific first)\n        for (const rule of matchingRules) {\n            // If this rule has an exclusion that matches, deny access\n            if (rule.excludeRegex && rule.excludeRegex.test(targetName)) {\n                return false;\n            }\n\n            // If this rule has an apply list, check if target is in it\n            if (rule.applyRegex) {\n                return rule.applyRegex.test(targetName);\n            }\n        }\n\n        // If we have rules but no specific apply/exclude, allow by default\n        return true;\n    }\n\n    isExcluded<T extends A_Component>(\n        ctor: T | A_TYPES__Component_Constructor<T>,\n        method: string\n    ): A_ManifestChecker {\n        const componentCtor = typeof ctor === 'function' ? ctor : ctor.constructor as A_TYPES__Component_Constructor;\n        return new A_ManifestChecker(this, componentCtor, method, true);\n    }\n}\n"]}