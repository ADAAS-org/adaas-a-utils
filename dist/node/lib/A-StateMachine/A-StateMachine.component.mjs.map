{"version":3,"sources":["../../../../src/lib/A-StateMachine/A-StateMachine.component.ts"],"names":[],"mappings":"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","file":"A-StateMachine.component.mjs","sourcesContent":["import { A_Component, A_Context, A_Feature, A_FormatterHelper, A_Scope } from \"@adaas/a-concept\";\nimport { A_StateMachineError } from \"./A-StateMachine.error\";\nimport { A_StateMachineFeatures } from \"./A-StateMachine.constants\";\nimport { A_StateMachineTransition } from \"./A-StateMachineTransition.context\";\nimport { A_Frame } from \"@adaas/a-frame\";\n\n/**\n * A_StateMachine is a powerful state machine implementation that allows you to define and manage\n * complex state transitions with validation, hooks, and error handling.\n * \n * @template T - A record type defining the state transitions and their associated data types.\n *               Each key represents a state name, and the value represents the data type for that state.\n * \n * @example\n * ```typescript\n * interface OrderStates {\n *   pending: { orderId: string };\n *   processing: { orderId: string; processedBy: string };\n *   completed: { orderId: string; completedAt: Date };\n *   cancelled: { orderId: string; reason: string };\n * }\n * \n * class OrderStateMachine extends A_StateMachine<OrderStates> {\n *   // Define custom transition logic\n *   async pending_processing(scope: A_Scope) {\n *     const operation = scope.resolve(A_StateMachineTransition)!;\n *     const { orderId } = operation.props;\n *     // Custom validation and business logic\n *   }\n * }\n * ```\n */\n\n@A_Frame.Namespace('A-Utils')\n@A_Frame.Component({\n    name: 'A-StateMachine',\n    description: 'A powerful state machine component for managing complex state transitions.'\n})\nexport class A_StateMachine<\n    T extends Record<string, any> = Record<string, any>\n> extends A_Component {\n\n    /**\n     * Internal promise that tracks the initialization state of the state machine.\n     * Used to ensure the state machine is properly initialized before allowing transitions.\n     */\n    protected _initialized?: Promise<void>;\n\n    /**\n     * Gets a promise that resolves when the state machine is fully initialized and ready for transitions.\n     * This ensures that all initialization hooks have been executed before allowing state transitions.\n     * \n     * @returns Promise<void> that resolves when initialization is complete\n     * \n     * @example\n     * ```typescript\n     * const stateMachine = new MyStateMachine();\n     * await stateMachine.ready; // Wait for initialization\n     * await stateMachine.transition('idle', 'running');\n     * ```\n     */\n    get ready(): Promise<void> {\n        if (!this._initialized) {\n            this._initialized = new Promise<void>(\n                async (resolve, reject) => {\n                    try {\n                        await this.call(A_StateMachineFeatures.onInitialize);\n\n                        resolve();\n                    } catch (error) {\n                        const wrappedError = new A_StateMachineError({\n                            title: A_StateMachineError.InitializationError,\n                            description: `An error occurred during state machine initialization.`,\n                            originalError: error\n                        });\n\n                        reject(wrappedError);\n                    }\n                }\n            );\n        }\n\n        return this._initialized;\n    }\n\n\n\n    /**\n     * Initialization hook that runs when the state machine is first created.\n     * This method can be extended to add custom initialization logic.\n     * \n     * @param args - Variable arguments passed during initialization\n     * @returns Promise<void>\n     * \n     * @example\n     * ```typescript\n     * class MyStateMachine extends A_StateMachine {\n     *   @A_Feature.Extend()\n     *   async [A_StateMachineFeatures.onInitialize]() {\n     *     // Custom initialization logic\n     *     console.log('State machine initialized');\n     *   }\n     * }\n     * ```\n     */\n    @A_Feature.Extend()\n    async [A_StateMachineFeatures.onInitialize](...args: any[]): Promise<void> {\n        // Initialization logic can be added here\n    }\n\n    /**\n     * Hook that runs before any state transition occurs.\n     * Use this to add validation, logging, or preparation logic that should run for all transitions.\n     * \n     * @param args - Variable arguments, typically includes the transition scope\n     * @returns Promise<void>\n     * \n     * @example\n     * ```typescript\n     * class MyStateMachine extends A_StateMachine {\n     *   @A_Feature.Extend()\n     *   async [A_StateMachineFeatures.onBeforeTransition](scope: A_Scope) {\n     *     const operation = scope.resolve(A_StateMachineTransition)!;\n     *     console.log(`Transitioning from ${operation.props.from} to ${operation.props.to}`);\n     *   }\n     * }\n     * ```\n     */\n    @A_Feature.Extend()\n    async [A_StateMachineFeatures.onBeforeTransition](...args: any[]): Promise<void> {\n\n    }\n\n    /**\n     * Hook that runs after a successful state transition.\n     * Use this to add cleanup, logging, or post-transition logic that should run for all transitions.\n     * \n     * @param args - Variable arguments, typically includes the transition scope\n     * @returns Promise<void>\n     * \n     * @example\n     * ```typescript\n     * class MyStateMachine extends A_StateMachine {\n     *   @A_Feature.Extend()\n     *   async [A_StateMachineFeatures.onAfterTransition](scope: A_Scope) {\n     *     const operation = scope.resolve(A_StateMachineTransition)!;\n     *     console.log(`Successfully transitioned to ${operation.props.to}`);\n     *   }\n     * }\n     * ```\n     */\n    @A_Feature.Extend()\n    async [A_StateMachineFeatures.onAfterTransition](...args: any[]): Promise<void> {\n\n    }\n\n    /**\n     * Error handling hook that runs when a transition fails.\n     * Use this to add custom error handling, logging, or recovery logic.\n     * \n     * @param args - Variable arguments, typically includes the error scope\n     * @returns Promise<void>\n     * \n     * @example\n     * ```typescript\n     * class MyStateMachine extends A_StateMachine {\n     *   @A_Feature.Extend()\n     *   async [A_StateMachineFeatures.onError](scope: A_Scope) {\n     *     const error = scope.resolve(A_StateMachineError);\n     *     console.error('Transition failed:', error?.message);\n     *   }\n     * }\n     * ```\n     */\n    @A_Feature.Extend()\n    async [A_StateMachineFeatures.onError](...args: any[]): Promise<void> {\n        // Default error handling logic can be added here\n    }\n\n\n\n    /**\n     * Executes a state transition from one state to another.\n     * This is the core method of the state machine that handles the complete transition lifecycle.\n     * \n     * @param from - The state to transition from (must be a key of T)\n     * @param to - The state to transition to (must be a key of T)\n     * @param props - Optional properties to pass to the transition context (should match T[keyof T])\n     * @returns Promise<void> that resolves when the transition is complete\n     * \n     * @throws {A_StateMachineError} When the transition fails for any reason\n     * \n     * @example\n     * ```typescript\n     * interface OrderStates {\n     *   pending: { orderId: string };\n     *   processing: { orderId: string; processedBy: string };\n     * }\n     * \n     * const orderMachine = new A_StateMachine<OrderStates>();\n     * \n     * // Transition with props\n     * await orderMachine.transition('pending', 'processing', {\n     *   orderId: '12345',\n     *   processedBy: 'user-456'\n     * });\n     * ```\n     * \n     * The transition process follows this lifecycle:\n     * 1. Wait for state machine initialization (ready)\n     * 2. Create transition name in camelCase format (e.g., \"pending_processing\")\n     * 3. Create operation context with transition data\n     * 4. Create isolated scope for the transition\n     * 5. Call onBeforeTransition hook\n     * 6. Execute the specific transition method (if defined)\n     * 7. Call onAfterTransition hook\n     * 8. Clean up scope and return result\n     * \n     * If any step fails, the onError hook is called and a wrapped error is thrown.\n     */\n    @A_Frame.Method({\n        name: 'transition',\n        description: 'Executes a state transition from one state to another.'\n    })\n    async transition(\n        /**\n         * The state to transition from\n         */\n        from: keyof T,\n        /**\n         * The state to transition to\n         */\n        to: keyof T,\n        /**\n         * Optional properties to pass to the transition context\n         */\n        props?: T[keyof T]\n    ): Promise<void> {\n\n        await this.ready;\n\n        const transitionName = `${A_FormatterHelper.toCamelCase(String(from))}_${A_FormatterHelper.toCamelCase(String(to))}`;\n\n        const transition = new A_StateMachineTransition({\n            from: String(from),\n            to: String(to),\n            props\n        });\n\n        const scope = new A_Scope({\n            name: `A-StateMachine-Transition-Scope-${transitionName}`,\n            fragments: [transition]\n        })\n            .inherit(A_Context.scope(this));\n\n        try {\n\n            await this.call(A_StateMachineFeatures.onBeforeTransition, scope);\n\n            await this.call(transitionName, scope);\n\n            await this.call(A_StateMachineFeatures.onAfterTransition, scope);\n\n            scope.destroy();\n\n            return transition.result;\n\n        } catch (error) {\n            const wrappedError = new A_StateMachineError({\n                title: A_StateMachineError.TransitionError,\n                description: `An error occurred while transitioning to \"${transitionName}\"`,\n                originalError: error\n            });\n\n            scope.register(wrappedError);\n\n            await this.call(A_StateMachineFeatures.onError, scope);\n\n            scope.destroy();\n\n            throw wrappedError;\n        }\n    }\n}\n\n\n"]}