{"version":3,"sources":["../../../../src/lib/A-Route/A-Route.entity.ts"],"names":["A_Route","A_Fragment","A_Frame"],"mappings":"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","file":"A-Route.entity.js","sourcesContent":["import { A_Fragment } from '@adaas/a-concept';\nimport { A_Frame } from '@adaas/a-frame';\n\n\n\n\n@A_Frame.Fragment({\n    namespace: 'A-Utils',\n    name: 'A-Route',\n    description: 'Route fragment that defines URL patterns for routing purposes. It supports dynamic parameters and query extraction, allowing for flexible route definitions. This fragment can be used in routing systems to match incoming URLs against defined routes and extract relevant parameters and query strings.'\n})\nexport class A_Route<\n    _TParams extends Record<string, any> = Record<string, any>,\n    _TQuery extends Record<string, any> = Record<string, any>\n> extends A_Fragment {\n\n    public url!: string;\n\n\n    constructor(\n        url: string | RegExp,\n    ) {\n        super();\n        this.url = url instanceof RegExp ? url.source : url;\n    }\n\n    /**\n     * Returns path only without query and hash\n     */\n    get path(): string {\n        const p = this.url.split('?')[0].split('#')[0];\n\n\n        //  ensure that last char is not /\n        //  and remove protocol and domain if present\n        if (p.includes('://')) {\n            const pathStartIndex = p.indexOf('/', p.indexOf('://') + 3);\n            if (pathStartIndex === -1) {\n                return '/';\n            } else {\n                const path = p.slice(pathStartIndex);\n                return path.endsWith('/') ? path.slice(0, -1) : path;\n            }\n        }\n        return p.endsWith('/') ? p.slice(0, -1) : p;\n    }\n    /**\n     * Returns array of parameter names in the route path\n     */\n    get params(): string[] {\n        return this.path\n            .match(/:([^\\/]+)/g)\n            ?.map((param) => param.slice(1))\n            || [];\n    }\n\n\n    /**\n     * Returns protocol based on URL scheme\n     */\n    get protocol(): string {\n        switch (true) {\n            case this.url.startsWith('http://'):\n                return 'http';\n            case this.url.startsWith('https://'):\n                return 'https';\n            case this.url.startsWith('ws://'):\n                return 'ws';\n            case this.url.startsWith('wss://'):\n                return 'wss';\n            default:\n                return this.url.includes('://') ? this.url.split('://')[0] : 'http';\n        }\n    }\n\n\n    extractParams(url: string): _TParams {\n        // Remove query string (anything after ?)\n        const cleanUrl = url.split('?')[0];\n\n        const urlSegments = cleanUrl.split('/').filter(Boolean);\n        const maskSegments = this.path.split('/').filter(Boolean);\n\n        const params = {};\n\n        for (let i = 0; i < maskSegments.length; i++) {\n\n            const maskSegment = maskSegments[i];\n            const urlSegment = urlSegments[i];\n\n            if (maskSegment.startsWith(':')) {\n                const paramName = maskSegment.slice(1); // Remove ':' from mask\n                params[paramName] = urlSegment;\n            } else if (maskSegment !== urlSegment) {\n                // If static segments don’t match → fail\n                return {} as _TParams;\n            }\n        }\n\n        return params as _TParams;\n    }\n\n    extractQuery(url: string): _TQuery {\n        const query: Record<string, string> = {};\n\n        // Take only the part after \"?\"\n        const queryString = url.split('?')[1];\n        if (!queryString) return query as _TQuery;\n\n        // Remove fragment (#...) if present\n        const cleanQuery = queryString.split('#')[0];\n\n        // Split into key=value pairs\n        for (const pair of cleanQuery.split('&')) {\n            if (!pair) continue;\n            const [key, value = ''] = pair.split('=');\n            query[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n\n        return query as _TQuery;\n    }\n\n\n\n    toString(): string {\n        // path can be like /api/v1/users/:id\n        // and because of that :id we need to replace it with regex that matches chars and numbers only   \n        return `${this.path}`;\n        // .replace(/\\/:([^\\/]+)/g, '\\\\/([^\\/]+)')\n    }\n\n    toRegExp(): RegExp {\n        return new RegExp(`^${this.path.replace(/\\/:([^\\/]+)/g, '/([^/]+)')}$`);\n    }\n\n    toAFeatureExtension(extensionScope: Array<string> = []): RegExp {\n        return new RegExp(`^${extensionScope.length\n            ? `(${extensionScope.join('|')})`\n            : '.*'\n            }\\\\.${this.path.replace(/\\/:([^\\/]+)/g, '/([^/]+)')}$`);\n    }\n}\n\n"]}