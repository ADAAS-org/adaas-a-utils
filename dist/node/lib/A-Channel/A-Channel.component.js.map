{"version":3,"sources":["../../../../src/lib/A-Channel/A-Channel.component.ts"],"names":["A_Channel","A_Component","A_ChannelFeatures","A_Scope","A_IdentityHelper","A_Context","A_ChannelRequest","A_ChannelError","A_OperationContext","A_Feature","A_Frame"],"mappings":";;;;;;;;;;;;;;;;;;;AAwDaA,iBAAA,GAAN,wBAAwBC,oBAAA,CAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqCvC,WAAA,GAAc;AACV,IAAA,KAAA,EAAM;AA9BV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAA,IAAA,CAAU,WAAA,GAAuB,KAAA;AAkBjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAA,IAAA,CAAU,MAAA,uBAA+B,GAAA,EAAI;AAAA,EAa7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,UAAA,GAAsB;AACtB,IAAA,OAAO,IAAA,CAAK,WAAA;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,IAAI,UAAA,GAA4B;AAC5B,IAAA,IAAI,CAAC,KAAK,YAAA,EAAc;AACpB,MAAA,IAAA,CAAK,YAAA,GAAe,KAAK,OAAA,EAAQ;AAAA,IACrC;AACA,IAAA,OAAO,IAAA,CAAK,YAAA;AAAA,EAChB;AAAA,EA+BA,MAAM,aAAa,IAAA,EAAa;AAAA,EAGhC;AAAA,EAuBA,MAAM,gBAAgB,IAAA,EAAa;AAAA,EAGnC;AAAA,EA4BA,MAAM,mBAAmB,IAAA,EAAa;AAAA,EAGtC;AAAA,EA2BA,MAAM,aAAa,IAAA,EAAa;AAAA,EAGhC;AAAA,EA0BA,MAAM,kBAAkB,IAAA,EAAa;AAAA,EAGrC;AAAA,EA2BA,MAAM,WAAW,IAAA,EAAa;AAAA,EAG9B;AAAA,EAyBA,MAAM,UAAU,IAAA,EAAa;AAAA,EAG7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAM,OAAA,GAAU;AACZ,IAAA,MAAM,IAAA,CAAK,IAAA,CAAKC,oCAAA,CAAkB,SAAS,CAAA;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAM,UAAA,GAAa;AACf,IAAA,MAAM,IAAA,CAAK,IAAA,CAAKA,oCAAA,CAAkB,YAAY,CAAA;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuCA,MAAM,QAGJ,MAAA,EAA0E;AAExE,IAAA,MAAM,IAAA,CAAK,UAAA;AAGX,IAAA,IAAA,CAAK,WAAA,GAAc,IAAA;AAGnB,IAAA,MAAM,YAAA,GAAe,IAAIC,gBAAA,CAAQ;AAAA,MAC7B,IAAA,EAAM,CAAA,wBAAA,EAA2BC,yBAAA,CAAiB,cAAA,EAAgB,CAAA;AAAA,KACrE,CAAA,CACI,OAAA,CAAQC,kBAAA,CAAU,KAAA,CAAM,IAAI,CAAC,CAAA;AAGlC,IAAA,MAAM,OAAA,GAAU,IAAIC,wCAAA,CAA2C,MAAM,CAAA;AAErE,IAAA,IAAI;AAEA,MAAA,YAAA,CAAa,SAAS,OAAO,CAAA;AAG7B,MAAA,MAAM,IAAA,CAAK,IAAA,CAAKJ,oCAAA,CAAkB,eAAA,EAAiB,YAAY,CAAA;AAC/D,MAAA,MAAM,IAAA,CAAK,IAAA,CAAKA,oCAAA,CAAkB,SAAA,EAAW,YAAY,CAAA;AACzD,MAAA,MAAM,IAAA,CAAK,IAAA,CAAKA,oCAAA,CAAkB,cAAA,EAAgB,YAAY,CAAA;AAE9D,MAAA,IAAA,CAAK,WAAA,GAAc,KAAA;AAEnB,MAAA,OAAO,OAAA;AAAA,IAEX,SAAS,KAAA,EAAO;AACZ,MAAA,IAAA,CAAK,WAAA,GAAc,KAAA;AAGnB,MAAA,MAAM,YAAA,GAAe,IAAIK,6BAAA,CAAe,KAAK,CAAA;AAC7C,MAAA,OAAA,CAAQ,KAAK,YAAY,CAAA;AACzB,MAAA,YAAA,CAAa,SAAS,YAAY,CAAA;AAGlC,MAAA,MAAM,IAAA,CAAK,IAAA,CAAKL,oCAAA,CAAkB,OAAA,EAAS,YAAY,CAAA;AAEvD,MAAA,YAAA,CAAa,OAAA,EAAQ;AAErB,MAAA,MAAM,YAAA;AAAA,IACV;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA4CA,MAAM,KACF,OAAA,EACa;AAEb,IAAA,MAAM,IAAA,CAAK,UAAA;AAGX,IAAA,IAAA,CAAK,WAAA,GAAc,IAAA;AAGnB,IAAA,MAAM,YAAA,GAAe,IAAIC,gBAAA,CAAQ;AAAA,MAC7B,IAAA,EAAM,CAAA,qBAAA,EAAwBC,yBAAA,CAAiB,cAAA,EAAgB,CAAA;AAAA,KAClE,CAAA,CACI,OAAA,CAAQC,kBAAA,CAAU,KAAA,CAAM,IAAI,CAAC,CAAA;AAIlC,IAAA,MAAM,OAAA,GAAU,IAAIG,6BAAA,CAAmB,MAAA,EAAQ,OAAO,CAAA;AAEtD,IAAA,IAAI;AAEA,MAAA,YAAA,CAAa,OAAA,CAAQH,kBAAA,CAAU,KAAA,CAAM,IAAI,CAAC,CAAA;AAC1C,MAAA,YAAA,CAAa,SAAS,OAAO,CAAA;AAG7B,MAAA,MAAM,IAAA,CAAK,IAAA,CAAKH,oCAAA,CAAkB,MAAA,EAAQ,YAAY,CAAA;AAEtD,MAAA,IAAA,CAAK,WAAA,GAAc,KAAA;AAAA,IAEvB,SAAS,KAAA,EAAO;AACZ,MAAA,IAAA,CAAK,WAAA,GAAc,KAAA;AAGnB,MAAA,MAAM,YAAA,GAAe,IAAIK,6BAAA,CAAe,KAAK,CAAA;AAC7C,MAAA,YAAA,CAAa,SAAS,YAAY,CAAA;AAClC,MAAA,OAAA,CAAQ,KAAK,YAAY,CAAA;AAGzB,MAAA,MAAM,IAAA,CAAK,IAAA,CAAKL,oCAAA,CAAkB,OAAA,EAAS,YAAY,CAAA;AAEvD,MAAA,YAAA,CAAa,OAAA,EAAQ;AAAA,IAIzB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,OAAA,GAAoG;AACtG,IAAA,MAAM,IAAA,CAAK,UAAA;AAEX,IAAA,IAAA,CAAK,WAAA,GAAc,IAAA;AAEnB,IAAA,MAAM,eAAe,IAAIC,gBAAA,CAAQ,EAAE,IAAA,EAAM,2BAA2BC,yBAAA,CAAiB,cAAA,EAAgB,CAAA,CAAA,EAAI,CAAA,CACpG,OAAA,CAAQC,kBAAA,CAAU,KAAA,CAAM,IAAI,CAAC,CAAA;AAGlC,IAAA,MAAM,OAAA,GAAU,IAAIG,6BAAA,CAAmB,SAAA,EAAW,EAAO,CAAA;AAEzD,IAAA,IAAI;AACA,MAAA,YAAA,CAAa,OAAA,CAAQH,kBAAA,CAAU,KAAA,CAAM,IAAI,CAAC,CAAA;AAC1C,MAAA,YAAA,CAAa,SAAS,OAAO,CAAA;AAG7B,MAAA,MAAM,IAAA,CAAK,IAAA,CAAKH,oCAAA,CAAkB,SAAA,EAAW,YAAY,CAAA;AAEzD,MAAA,IAAA,CAAK,WAAA,GAAc,KAAA;AAEnB,MAAA,OAAO,OAAA;AAAA,IAEX,SAAS,KAAA,EAAO;AAEZ,MAAA,IAAA,CAAK,WAAA,GAAc,KAAA;AAEnB,MAAA,MAAM,YAAA,GAAe,IAAIK,6BAAA,CAAe,KAAK,CAAA;AAE7C,MAAA,OAAA,CAAQ,KAAK,YAAY,CAAA;AAEzB,MAAA,MAAM,IAAA,CAAK,IAAA,CAAKL,oCAAA,CAAkB,OAAA,EAAS,YAAY,CAAA;AAEvD,MAAA,OAAO,OAAA;AAAA,IACX;AAAA,EACJ;AAEJ;AAzaU,eAAA,CAAA;AAAA,EAHLO,mBAAU,MAAA,CAAO;AAAA,IACd,MAAMP,oCAAA,CAAkB;AAAA,GAC3B;AAAA,CAAA,EA7FQF,iBAAA,CA8FH,SAAA,EAAA,WAAA,EAAA,CAAA,CAAA;AA0BA,eAAA,CAAA;AAAA,EAHLS,mBAAU,MAAA,CAAO;AAAA,IACd,MAAMP,oCAAA,CAAkB;AAAA,GAC3B;AAAA,CAAA,EAvHQF,iBAAA,CAwHH,SAAA,EAAA,cAAA,EAAA,CAAA,CAAA;AA+BA,eAAA,CAAA;AAAA,EAHLS,mBAAU,MAAA,CAAO;AAAA,IACd,MAAMP,oCAAA,CAAkB;AAAA,GAC3B;AAAA,CAAA,EAtJQF,iBAAA,CAuJH,SAAA,EAAA,iBAAA,EAAA,CAAA,CAAA;AA8BA,eAAA,CAAA;AAAA,EAHLS,mBAAU,MAAA,CAAO;AAAA,IACd,MAAMP,oCAAA,CAAkB;AAAA,GAC3B;AAAA,CAAA,EApLQF,iBAAA,CAqLH,SAAA,EAAA,WAAA,EAAA,CAAA,CAAA;AA6BA,eAAA,CAAA;AAAA,EAHLS,mBAAU,MAAA,CAAO;AAAA,IACd,MAAMP,oCAAA,CAAkB;AAAA,GAC3B;AAAA,CAAA,EAjNQF,iBAAA,CAkNH,SAAA,EAAA,gBAAA,EAAA,CAAA,CAAA;AA8BA,eAAA,CAAA;AAAA,EAHLS,mBAAU,MAAA,CAAO;AAAA,IACd,MAAMP,oCAAA,CAAkB;AAAA,GAC3B;AAAA,CAAA,EA/OQF,iBAAA,CAgPH,SAAA,EAAA,SAAA,EAAA,CAAA,CAAA;AA4BA,eAAA,CAAA;AAAA,EAHLS,mBAAU,MAAA,CAAO;AAAA,IACd,MAAMP,oCAAA,CAAkB;AAAA,GAC3B;AAAA,CAAA,EA3QQF,iBAAA,CA4QH,SAAA,EAAA,QAAA,EAAA,CAAA,CAAA;AA5QGA,iBAAA,GAAN,eAAA,CAAA;AAAA,EALNU,cAAA,CAAQ,UAAU,SAAS,CAAA;AAAA,EAC3BA,eAAQ,SAAA,CAAU;AAAA,IACf,IAAA,EAAM,WAAA;AAAA,IACN,WAAA,EAAa;AAAA,GAChB;AAAA,CAAA,EACYV,iBAAA,CAAA","file":"A-Channel.component.js","sourcesContent":["import { A_Component, A_Context, A_Feature, A_IdentityHelper, A_Scope } from \"@adaas/a-concept\";\nimport { A_ChannelError } from \"./A-Channel.error\";\nimport { A_ChannelFeatures } from \"./A-Channel.constants\";\nimport { A_OperationContext } from \"@adaas/a-utils/a-operation\";\nimport { A_ChannelRequest } from \"./A-ChannelRequest.context\";\nimport { A_Frame } from \"@adaas/a-frame\";\n\n/**\n * A-Channel - A powerful, extensible communication channel component\n * \n * A-Channel provides a structured approach to implementing various communication patterns\n * such as HTTP clients, WebSocket connections, message queues, and other messaging systems.\n * It offers a complete lifecycle management system with extensible hooks for custom behavior.\n * \n * ## Key Features:\n * - üîÑ **Lifecycle Management** - Complete connection and processing lifecycle with hooks\n * - üì° **Multiple Communication Patterns** - Request/Response and Fire-and-Forget messaging  \n * - üõ°Ô∏è **Error Handling** - Comprehensive error capture and management\n * - üéØ **Type Safety** - Full TypeScript support with generic types\n * - üîß **Extensible** - Component-based architecture for custom behavior\n * - ‚ö° **Concurrent Processing** - Handle multiple requests simultaneously\n * \n * ## Basic Usage:\n * ```typescript\n * const channel = new A_Channel();\n * A_Context.root.register(channel);\n * \n * // Request/Response pattern\n * const response = await channel.request({ action: 'getData', id: 123 });\n * \n * // Fire-and-forget pattern  \n * await channel.send({ type: 'notification', message: 'Hello World' });\n * ```\n * \n * ## Custom Implementation:\n * ```typescript\n * class HttpChannel extends A_Channel {}\n * \n * class HttpProcessor extends A_Component {\n *     @A_Feature.Extend({ scope: [HttpChannel] })\n *     async [A_ChannelFeatures.onRequest](\n *         @A_Inject(A_ChannelRequest) context: A_ChannelRequest\n *     ) {\n *         const response = await fetch(context.params.url);\n *         (context as any)._result = await response.json();\n *     }\n * }\n * ```\n * \n * @see {@link ./README.md} For complete documentation and examples\n */\n@A_Frame.Namespace('A-Utils')\n@A_Frame.Component({\n    name: 'A-Channel',\n    description: 'Component uses as abstract channel for communication patterns. Can be inherited and extended to implement custom channels.'\n})\nexport class A_Channel extends A_Component {\n\n    /**\n     * Indicates whether the channel is currently processing requests.\n     * This flag is managed automatically during request/send operations.\n     * \n     * @readonly\n     */\n    protected _processing: boolean = false;\n\n    /**\n     * Promise that resolves when the channel initialization is complete.\n     * Ensures that onConnect lifecycle hook has been executed before\n     * any communication operations.\n     * \n     * @private\n     */\n    protected _initialized?: Promise<void>;\n\n    /**\n     * Internal cache storage for channel-specific data.\n     * Can be used by custom implementations for caching responses,\n     * connection pools, or other channel-specific state.\n     * \n     * @protected\n     */\n    protected _cache: Map<string, any> = new Map();\n\n    /**\n     * Creates a new A_Channel instance.\n     * \n     * The channel must be registered with A_Context before use:\n     * ```typescript\n     * const channel = new A_Channel();\n     * A_Context.root.register(channel);\n     * ```\n     */\n    constructor() {\n        super();\n    }\n\n    /**\n     * Indicates whether the channel is currently processing requests.\n     * \n     * @returns {boolean} True if channel is processing, false otherwise\n     */\n    get processing(): boolean {\n        return this._processing;\n    }\n\n    /**\n     * Promise that resolves when the channel is fully initialized.\n     * \n     * Automatically calls the onConnect lifecycle hook if not already called.\n     * This ensures the channel is ready for communication operations.\n     * \n     * @returns {Promise<void>} Promise that resolves when initialization is complete\n     */\n    get initialize(): Promise<void> {\n        if (!this._initialized) {\n            this._initialized = this.connect();\n        }\n        return this._initialized;\n    }\n\n    // ==========================================================\n    // ================ Lifecycle Extension Points =============\n    // ==========================================================\n\n    /**\n     * Connection lifecycle hook - called during channel initialization.\n     * \n     * Override this method in custom components to implement connection logic:\n     * - Initialize network connections\n     * - Load configuration\n     * - Validate environment\n     * - Set up connection pools\n     * \n     * @example\n     * ```typescript\n     * class DatabaseChannel extends A_Channel {}\n     * \n     * class DatabaseConnector extends A_Component {\n     *     @A_Feature.Extend({ scope: [DatabaseChannel] })\n     *     async [A_ChannelFeatures.onConnect]() {\n     *         await this.initializeDatabase();\n     *         console.log('Database channel connected');\n     *     }\n     * }\n     * ```\n     */\n    @A_Feature.Extend({\n        name: A_ChannelFeatures.onConnect\n    })\n    async onConnect(...args: any[]) {\n        // Default implementation - no operation\n        // Override in custom implementations\n    }\n\n    /**\n     * Disconnection lifecycle hook - called during channel cleanup.\n     * \n     * Override this method in custom components to implement cleanup logic:\n     * - Close network connections\n     * - Save state\n     * - Release resources\n     * - Clear caches\n     * \n     * @example\n     * ```typescript\n     * @A_Feature.Extend({ scope: [DatabaseChannel] })\n     * async [A_ChannelFeatures.onDisconnect]() {\n     *     await this.closeConnections();\n     *     console.log('Database channel disconnected');\n     * }\n     * ```\n     */\n    @A_Feature.Extend({\n        name: A_ChannelFeatures.onDisconnect\n    })\n    async onDisconnect(...args: any[]) {\n        // Default implementation - no operation\n        // Override in custom implementations\n    }\n\n    /**\n     * Pre-request processing hook - called before main request processing.\n     * \n     * Use this hook for:\n     * - Request validation\n     * - Authentication\n     * - Rate limiting\n     * - Logging\n     * - Request transformation\n     * \n     * @example\n     * ```typescript\n     * @A_Feature.Extend({ scope: [HttpChannel] })\n     * async [A_ChannelFeatures.onBeforeRequest](\n     *     @A_Inject(A_ChannelRequest) context: A_ChannelRequest\n     * ) {\n     *     // Validate required parameters\n     *     if (!context.params.url) {\n     *         throw new Error('URL is required');\n     *     }\n     * }\n     * ```\n     */\n    @A_Feature.Extend({\n        name: A_ChannelFeatures.onBeforeRequest\n    })\n    async onBeforeRequest(...args: any[]) {\n        // Default implementation - no operation\n        // Override in custom implementations\n    }\n\n    /**\n     * Main request processing hook - core business logic goes here.\n     * \n     * This is where the main communication logic should be implemented:\n     * - Make HTTP requests\n     * - Send messages to queues\n     * - Execute database queries\n     * - Process business logic\n     * \n     * Set the result in the context: `(context as any)._result = yourResult;`\n     * \n     * @example\n     * ```typescript\n     * @A_Feature.Extend({ scope: [HttpChannel] })\n     * async [A_ChannelFeatures.onRequest](\n     *     @A_Inject(A_ChannelRequest) context: A_ChannelRequest\n     * ) {\n     *     const response = await fetch(context.params.url);\n     *     (context as any)._result = await response.json();\n     * }\n     * ```\n     */\n    @A_Feature.Extend({\n        name: A_ChannelFeatures.onRequest\n    })\n    async onRequest(...args: any[]) {\n        // Default implementation - no operation\n        // Override in custom implementations\n    }\n\n    /**\n     * Post-request processing hook - called after successful request processing.\n     * \n     * Use this hook for:\n     * - Response transformation\n     * - Logging\n     * - Analytics\n     * - Caching results\n     * - Cleanup\n     * \n     * @example\n     * ```typescript\n     * @A_Feature.Extend({ scope: [HttpChannel] })\n     * async [A_ChannelFeatures.onAfterRequest](\n     *     @A_Inject(A_ChannelRequest) context: A_ChannelRequest\n     * ) {\n     *     console.log(`Request completed in ${Date.now() - context.startTime}ms`);\n     *     await this.cacheResponse(context.params, context.data);\n     * }\n     * ```\n     */\n    @A_Feature.Extend({\n        name: A_ChannelFeatures.onAfterRequest\n    })\n    async onAfterRequest(...args: any[]) {\n        // Default implementation - no operation\n        // Override in custom implementations\n    }\n\n    /**\n     * Error handling hook - called when any operation fails.\n     * \n     * Use this hook for:\n     * - Error logging\n     * - Error transformation\n     * - Alerting\n     * - Retry logic\n     * - Fallback mechanisms\n     * \n     * @example\n     * ```typescript\n     * @A_Feature.Extend({ scope: [HttpChannel] })\n     * async [A_ChannelFeatures.onError](\n     *     @A_Inject(A_ChannelRequest) context: A_ChannelRequest\n     * ) {\n     *     console.error('Request failed:', context.params, context.failed);\n     *     await this.logError(context);\n     *     await this.sendAlert(context);\n     * }\n     * ```\n     */\n    @A_Feature.Extend({\n        name: A_ChannelFeatures.onError\n    })\n    async onError(...args: any[]) {\n        // Default implementation - no operation\n        // Override in custom implementations\n    }\n\n    /**\n     * Send operation hook - called for fire-and-forget messaging.\n     * \n     * Use this hook for:\n     * - Message broadcasting\n     * - Event publishing\n     * - Notification sending\n     * - Queue operations\n     * \n     * @example\n     * ```typescript\n     * @A_Feature.Extend({ scope: [EventChannel] })\n     * async [A_ChannelFeatures.onSend](\n     *     @A_Inject(A_ChannelRequest) context: A_ChannelRequest\n     * ) {\n     *     const { eventType, payload } = context.params;\n     *     await this.publishEvent(eventType, payload);\n     * }\n     * ```\n     */\n    @A_Feature.Extend({\n        name: A_ChannelFeatures.onSend\n    })\n    async onSend(...args: any[]) {\n        // Default implementation - no operation\n        // Override in custom implementations\n    }\n\n    // ==========================================================\n    // ================= Public API Methods ===================\n    // ==========================================================\n\n    /**\n     * Initializes the channel by calling the onConnect lifecycle hook.\n     * \n     * This method is called automatically when accessing the `initialize` property.\n     * You can also call it manually if needed.\n     * \n     * @returns {Promise<void>} Promise that resolves when connection is established\n     */\n    async connect() {\n        await this.call(A_ChannelFeatures.onConnect);\n    }\n\n    /**\n     * Disconnects the channel by calling the onDisconnect lifecycle hook.\n     * \n     * Use this method to properly cleanup resources when the channel is no longer needed.\n     * \n     * @returns {Promise<void>} Promise that resolves when cleanup is complete\n     */\n    async disconnect() {\n        await this.call(A_ChannelFeatures.onDisconnect);\n    }\n\n    /**\n     * Sends a request and waits for a response (Request/Response pattern).\n     * \n     * This method follows the complete request lifecycle:\n     * 1. Ensures channel is initialized\n     * 2. Creates request scope and context\n     * 3. Calls onBeforeRequest hook\n     * 4. Calls onRequest hook (main processing)\n     * 5. Calls onAfterRequest hook\n     * 6. Returns the response context\n     * \n     * If any step fails, the onError hook is called and the error is captured\n     * in the returned context.\n     * \n     * @template _ParamsType The type of request parameters\n     * @template _ResultType The type of response data\n     * @param params The request parameters\n     * @returns {Promise<A_ChannelRequest<_ParamsType, _ResultType>>} Request context with response\n     * \n     * @example\n     * ```typescript\n     * // Basic usage\n     * const response = await channel.request({ action: 'getData', id: 123 });\n     * \n     * // Typed usage\n     * interface UserRequest { userId: string; }\n     * interface UserResponse { name: string; email: string; }\n     * \n     * const userResponse = await channel.request<UserRequest, UserResponse>({\n     *     userId: 'user-123'\n     * });\n     * \n     * if (!userResponse.failed) {\n     *     console.log('User:', userResponse.data.name);\n     * }\n     * ```\n     */\n    async request<\n        _ParamsType extends Record<string, any> = Record<string, any>,\n        _ResultType extends Record<string, any> = Record<string, any>,\n    >(params: _ParamsType): Promise<A_ChannelRequest<_ParamsType, _ResultType>> {\n        // Ensure channel is initialized before processing\n        await this.initialize;\n\n        // Set processing flag\n        this._processing = true;\n\n        // Create isolated scope for this request\n        const requestScope = new A_Scope({\n            name: `a-channel@scope:request:${A_IdentityHelper.generateTimeId()}`\n        })\n            .inherit(A_Context.scope(this));\n\n        // Create request context\n        const context = new A_ChannelRequest<_ParamsType, _ResultType>(params);\n\n        try {\n            // Set up dependency injection scope\n            requestScope.register(context);\n\n            // Execute request lifecycle\n            await this.call(A_ChannelFeatures.onBeforeRequest, requestScope);\n            await this.call(A_ChannelFeatures.onRequest, requestScope);\n            await this.call(A_ChannelFeatures.onAfterRequest, requestScope);\n\n            this._processing = false;\n\n            return context;\n\n        } catch (error) {\n            this._processing = false;\n\n            // Create channel-specific error\n            const channelError = new A_ChannelError(error);\n            context.fail(channelError);\n            requestScope.register(channelError);\n\n            // Call error handling hook\n            await this.call(A_ChannelFeatures.onError, requestScope);\n\n            requestScope.destroy();\n\n            throw channelError;\n        }\n    }\n\n    /**\n     * Sends a fire-and-forget message (Send pattern).\n     * \n     * This method is used for one-way communication where no response is expected:\n     * - Event broadcasting\n     * - Notification sending\n     * - Message queuing\n     * - Logging operations\n     * \n     * The method follows this lifecycle:\n     * 1. Ensures channel is initialized\n     * 2. Creates send scope and context\n     * 3. Calls onSend hook\n     * 4. Completes without returning data\n     * \n     * If the operation fails, the onError hook is called but no error is thrown\n     * to the caller (fire-and-forget semantics).\n     * \n     * @template _ParamsType The type of message parameters\n     * @param message The message to send\n     * @returns {Promise<void>} Promise that resolves when send is complete\n     * \n     * @example\n     * ```typescript\n     * // Send notification\n     * await channel.send({\n     *     type: 'user.login',\n     *     userId: 'user-123',\n     *     timestamp: new Date().toISOString()\n     * });\n     * \n     * // Send to message queue\n     * await channel.send({\n     *     queue: 'email-queue',\n     *     payload: {\n     *         to: 'user@example.com',\n     *         subject: 'Welcome!',\n     *         body: 'Welcome to our service!'\n     *     }\n     * });\n     * ```\n     */\n    async send<_ParamsType extends Record<string, any> = Record<string, any>>(\n        message: _ParamsType\n    ): Promise<void> {\n        // Ensure channel is initialized before processing\n        await this.initialize;\n\n        // Set processing flag\n        this._processing = true;\n\n        // Create isolated scope for this send operation\n        const requestScope = new A_Scope({\n            name: `a-channel@scope:send:${A_IdentityHelper.generateTimeId()}`\n        })\n            .inherit(A_Context.scope(this));\n\n\n        // Create request context for the message\n        const context = new A_OperationContext('send', message);\n\n        try {\n            // Set up dependency injection scope\n            requestScope.inherit(A_Context.scope(this));\n            requestScope.register(context);\n\n            // Execute send operation\n            await this.call(A_ChannelFeatures.onSend, requestScope);\n\n            this._processing = false;\n\n        } catch (error) {\n            this._processing = false;\n\n            // Create channel-specific error\n            const channelError = new A_ChannelError(error);\n            requestScope.register(channelError);\n            context.fail(channelError);\n\n            // Call error handling hook\n            await this.call(A_ChannelFeatures.onError, requestScope);\n\n            requestScope.destroy();\n\n            // Note: We don't re-throw the error for fire-and-forget operations\n            // The error is handled by the onError hook\n        }\n    }\n\n    /**\n     * @deprecated This method is deprecated and will be removed in future versions.\n     * Use request() or send() methods instead depending on your communication pattern.\n     * \n     * For request/response pattern: Use request()\n     * For fire-and-forget pattern: Use send()\n     * For consumer patterns: Implement custom consumer logic using request() in a loop\n     */\n    async consume<T extends Record<string, any> = Record<string, any>>(): Promise<A_OperationContext<any, T>> {\n        await this.initialize;\n\n        this._processing = true;\n\n        const requestScope = new A_Scope({ name: `a-channel@scope:consume:${A_IdentityHelper.generateTimeId()}` })\n            .inherit(A_Context.scope(this));\n\n\n        const context = new A_OperationContext('consume', {} as T);\n\n        try {\n            requestScope.inherit(A_Context.scope(this));\n            requestScope.register(context);\n\n\n            await this.call(A_ChannelFeatures.onConsume, requestScope);\n\n            this._processing = false;\n\n            return context as A_OperationContext<any, T>;\n\n        } catch (error) {\n\n            this._processing = false;\n\n            const channelError = new A_ChannelError(error)\n\n            context.fail(channelError);\n\n            await this.call(A_ChannelFeatures.onError, requestScope);\n\n            return context as A_OperationContext<any, T>;\n        }\n    }\n\n}"]}